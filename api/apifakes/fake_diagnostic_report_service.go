// Code generated by counterfeiter. DO NOT EDIT.
package apifakes

import (
	"context"
	"sync"
	"time"

	"github.com/jmelchio/vetlab/api"
	"github.com/jmelchio/vetlab/model"
)

type FakeDiagnosticReportService struct {
	SumbmitDiagnosticReportStub        func(ctx context.Context, diagReport model.DiagnosticReport) (*model.DiagnosticReport, error)
	sumbmitDiagnosticReportMutex       sync.RWMutex
	sumbmitDiagnosticReportArgsForCall []struct {
		ctx        context.Context
		diagReport model.DiagnosticReport
	}
	sumbmitDiagnosticReportReturns struct {
		result1 *model.DiagnosticReport
		result2 error
	}
	sumbmitDiagnosticReportReturnsOnCall map[int]struct {
		result1 *model.DiagnosticReport
		result2 error
	}
	FindReportByDateRangeStub        func(ctx context.Context, start time.Time, end time.Time, vetOrg model.VetOrg) ([]model.DiagnosticReport, error)
	findReportByDateRangeMutex       sync.RWMutex
	findReportByDateRangeArgsForCall []struct {
		ctx    context.Context
		start  time.Time
		end    time.Time
		vetOrg model.VetOrg
	}
	findReportByDateRangeReturns struct {
		result1 []model.DiagnosticReport
		result2 error
	}
	findReportByDateRangeReturnsOnCall map[int]struct {
		result1 []model.DiagnosticReport
		result2 error
	}
	FindReportByIDStub        func(ctx context.Context, reportID uint) (*model.DiagnosticReport, error)
	findReportByIDMutex       sync.RWMutex
	findReportByIDArgsForCall []struct {
		ctx      context.Context
		reportID uint
	}
	findReportByIDReturns struct {
		result1 *model.DiagnosticReport
		result2 error
	}
	findReportByIDReturnsOnCall map[int]struct {
		result1 *model.DiagnosticReport
		result2 error
	}
	FindReportByVetOrgStub        func(ctx context.Context, vetOrg model.VetOrg) ([]model.DiagnosticReport, error)
	findReportByVetOrgMutex       sync.RWMutex
	findReportByVetOrgArgsForCall []struct {
		ctx    context.Context
		vetOrg model.VetOrg
	}
	findReportByVetOrgReturns struct {
		result1 []model.DiagnosticReport
		result2 error
	}
	findReportByVetOrgReturnsOnCall map[int]struct {
		result1 []model.DiagnosticReport
		result2 error
	}
	FindReportByUserStub        func(ctx context.Context, user model.User) ([]model.DiagnosticReport, error)
	findReportByUserMutex       sync.RWMutex
	findReportByUserArgsForCall []struct {
		ctx  context.Context
		user model.User
	}
	findReportByUserReturns struct {
		result1 []model.DiagnosticReport
		result2 error
	}
	findReportByUserReturnsOnCall map[int]struct {
		result1 []model.DiagnosticReport
		result2 error
	}
	FindReportByCustomerStub        func(ctx context.Context, customer model.Customer) ([]model.DiagnosticReport, error)
	findReportByCustomerMutex       sync.RWMutex
	findReportByCustomerArgsForCall []struct {
		ctx      context.Context
		customer model.Customer
	}
	findReportByCustomerReturns struct {
		result1 []model.DiagnosticReport
		result2 error
	}
	findReportByCustomerReturnsOnCall map[int]struct {
		result1 []model.DiagnosticReport
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeDiagnosticReportService) SumbmitDiagnosticReport(ctx context.Context, diagReport model.DiagnosticReport) (*model.DiagnosticReport, error) {
	fake.sumbmitDiagnosticReportMutex.Lock()
	ret, specificReturn := fake.sumbmitDiagnosticReportReturnsOnCall[len(fake.sumbmitDiagnosticReportArgsForCall)]
	fake.sumbmitDiagnosticReportArgsForCall = append(fake.sumbmitDiagnosticReportArgsForCall, struct {
		ctx        context.Context
		diagReport model.DiagnosticReport
	}{ctx, diagReport})
	fake.recordInvocation("SumbmitDiagnosticReport", []interface{}{ctx, diagReport})
	fake.sumbmitDiagnosticReportMutex.Unlock()
	if fake.SumbmitDiagnosticReportStub != nil {
		return fake.SumbmitDiagnosticReportStub(ctx, diagReport)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.sumbmitDiagnosticReportReturns.result1, fake.sumbmitDiagnosticReportReturns.result2
}

func (fake *FakeDiagnosticReportService) SumbmitDiagnosticReportCallCount() int {
	fake.sumbmitDiagnosticReportMutex.RLock()
	defer fake.sumbmitDiagnosticReportMutex.RUnlock()
	return len(fake.sumbmitDiagnosticReportArgsForCall)
}

func (fake *FakeDiagnosticReportService) SumbmitDiagnosticReportArgsForCall(i int) (context.Context, model.DiagnosticReport) {
	fake.sumbmitDiagnosticReportMutex.RLock()
	defer fake.sumbmitDiagnosticReportMutex.RUnlock()
	return fake.sumbmitDiagnosticReportArgsForCall[i].ctx, fake.sumbmitDiagnosticReportArgsForCall[i].diagReport
}

func (fake *FakeDiagnosticReportService) SumbmitDiagnosticReportReturns(result1 *model.DiagnosticReport, result2 error) {
	fake.SumbmitDiagnosticReportStub = nil
	fake.sumbmitDiagnosticReportReturns = struct {
		result1 *model.DiagnosticReport
		result2 error
	}{result1, result2}
}

func (fake *FakeDiagnosticReportService) SumbmitDiagnosticReportReturnsOnCall(i int, result1 *model.DiagnosticReport, result2 error) {
	fake.SumbmitDiagnosticReportStub = nil
	if fake.sumbmitDiagnosticReportReturnsOnCall == nil {
		fake.sumbmitDiagnosticReportReturnsOnCall = make(map[int]struct {
			result1 *model.DiagnosticReport
			result2 error
		})
	}
	fake.sumbmitDiagnosticReportReturnsOnCall[i] = struct {
		result1 *model.DiagnosticReport
		result2 error
	}{result1, result2}
}

func (fake *FakeDiagnosticReportService) FindReportByDateRange(ctx context.Context, start time.Time, end time.Time, vetOrg model.VetOrg) ([]model.DiagnosticReport, error) {
	fake.findReportByDateRangeMutex.Lock()
	ret, specificReturn := fake.findReportByDateRangeReturnsOnCall[len(fake.findReportByDateRangeArgsForCall)]
	fake.findReportByDateRangeArgsForCall = append(fake.findReportByDateRangeArgsForCall, struct {
		ctx    context.Context
		start  time.Time
		end    time.Time
		vetOrg model.VetOrg
	}{ctx, start, end, vetOrg})
	fake.recordInvocation("FindReportByDateRange", []interface{}{ctx, start, end, vetOrg})
	fake.findReportByDateRangeMutex.Unlock()
	if fake.FindReportByDateRangeStub != nil {
		return fake.FindReportByDateRangeStub(ctx, start, end, vetOrg)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.findReportByDateRangeReturns.result1, fake.findReportByDateRangeReturns.result2
}

func (fake *FakeDiagnosticReportService) FindReportByDateRangeCallCount() int {
	fake.findReportByDateRangeMutex.RLock()
	defer fake.findReportByDateRangeMutex.RUnlock()
	return len(fake.findReportByDateRangeArgsForCall)
}

func (fake *FakeDiagnosticReportService) FindReportByDateRangeArgsForCall(i int) (context.Context, time.Time, time.Time, model.VetOrg) {
	fake.findReportByDateRangeMutex.RLock()
	defer fake.findReportByDateRangeMutex.RUnlock()
	return fake.findReportByDateRangeArgsForCall[i].ctx, fake.findReportByDateRangeArgsForCall[i].start, fake.findReportByDateRangeArgsForCall[i].end, fake.findReportByDateRangeArgsForCall[i].vetOrg
}

func (fake *FakeDiagnosticReportService) FindReportByDateRangeReturns(result1 []model.DiagnosticReport, result2 error) {
	fake.FindReportByDateRangeStub = nil
	fake.findReportByDateRangeReturns = struct {
		result1 []model.DiagnosticReport
		result2 error
	}{result1, result2}
}

func (fake *FakeDiagnosticReportService) FindReportByDateRangeReturnsOnCall(i int, result1 []model.DiagnosticReport, result2 error) {
	fake.FindReportByDateRangeStub = nil
	if fake.findReportByDateRangeReturnsOnCall == nil {
		fake.findReportByDateRangeReturnsOnCall = make(map[int]struct {
			result1 []model.DiagnosticReport
			result2 error
		})
	}
	fake.findReportByDateRangeReturnsOnCall[i] = struct {
		result1 []model.DiagnosticReport
		result2 error
	}{result1, result2}
}

func (fake *FakeDiagnosticReportService) FindReportByID(ctx context.Context, reportID uint) (*model.DiagnosticReport, error) {
	fake.findReportByIDMutex.Lock()
	ret, specificReturn := fake.findReportByIDReturnsOnCall[len(fake.findReportByIDArgsForCall)]
	fake.findReportByIDArgsForCall = append(fake.findReportByIDArgsForCall, struct {
		ctx      context.Context
		reportID uint
	}{ctx, reportID})
	fake.recordInvocation("FindReportByID", []interface{}{ctx, reportID})
	fake.findReportByIDMutex.Unlock()
	if fake.FindReportByIDStub != nil {
		return fake.FindReportByIDStub(ctx, reportID)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.findReportByIDReturns.result1, fake.findReportByIDReturns.result2
}

func (fake *FakeDiagnosticReportService) FindReportByIDCallCount() int {
	fake.findReportByIDMutex.RLock()
	defer fake.findReportByIDMutex.RUnlock()
	return len(fake.findReportByIDArgsForCall)
}

func (fake *FakeDiagnosticReportService) FindReportByIDArgsForCall(i int) (context.Context, uint) {
	fake.findReportByIDMutex.RLock()
	defer fake.findReportByIDMutex.RUnlock()
	return fake.findReportByIDArgsForCall[i].ctx, fake.findReportByIDArgsForCall[i].reportID
}

func (fake *FakeDiagnosticReportService) FindReportByIDReturns(result1 *model.DiagnosticReport, result2 error) {
	fake.FindReportByIDStub = nil
	fake.findReportByIDReturns = struct {
		result1 *model.DiagnosticReport
		result2 error
	}{result1, result2}
}

func (fake *FakeDiagnosticReportService) FindReportByIDReturnsOnCall(i int, result1 *model.DiagnosticReport, result2 error) {
	fake.FindReportByIDStub = nil
	if fake.findReportByIDReturnsOnCall == nil {
		fake.findReportByIDReturnsOnCall = make(map[int]struct {
			result1 *model.DiagnosticReport
			result2 error
		})
	}
	fake.findReportByIDReturnsOnCall[i] = struct {
		result1 *model.DiagnosticReport
		result2 error
	}{result1, result2}
}

func (fake *FakeDiagnosticReportService) FindReportByVetOrg(ctx context.Context, vetOrg model.VetOrg) ([]model.DiagnosticReport, error) {
	fake.findReportByVetOrgMutex.Lock()
	ret, specificReturn := fake.findReportByVetOrgReturnsOnCall[len(fake.findReportByVetOrgArgsForCall)]
	fake.findReportByVetOrgArgsForCall = append(fake.findReportByVetOrgArgsForCall, struct {
		ctx    context.Context
		vetOrg model.VetOrg
	}{ctx, vetOrg})
	fake.recordInvocation("FindReportByVetOrg", []interface{}{ctx, vetOrg})
	fake.findReportByVetOrgMutex.Unlock()
	if fake.FindReportByVetOrgStub != nil {
		return fake.FindReportByVetOrgStub(ctx, vetOrg)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.findReportByVetOrgReturns.result1, fake.findReportByVetOrgReturns.result2
}

func (fake *FakeDiagnosticReportService) FindReportByVetOrgCallCount() int {
	fake.findReportByVetOrgMutex.RLock()
	defer fake.findReportByVetOrgMutex.RUnlock()
	return len(fake.findReportByVetOrgArgsForCall)
}

func (fake *FakeDiagnosticReportService) FindReportByVetOrgArgsForCall(i int) (context.Context, model.VetOrg) {
	fake.findReportByVetOrgMutex.RLock()
	defer fake.findReportByVetOrgMutex.RUnlock()
	return fake.findReportByVetOrgArgsForCall[i].ctx, fake.findReportByVetOrgArgsForCall[i].vetOrg
}

func (fake *FakeDiagnosticReportService) FindReportByVetOrgReturns(result1 []model.DiagnosticReport, result2 error) {
	fake.FindReportByVetOrgStub = nil
	fake.findReportByVetOrgReturns = struct {
		result1 []model.DiagnosticReport
		result2 error
	}{result1, result2}
}

func (fake *FakeDiagnosticReportService) FindReportByVetOrgReturnsOnCall(i int, result1 []model.DiagnosticReport, result2 error) {
	fake.FindReportByVetOrgStub = nil
	if fake.findReportByVetOrgReturnsOnCall == nil {
		fake.findReportByVetOrgReturnsOnCall = make(map[int]struct {
			result1 []model.DiagnosticReport
			result2 error
		})
	}
	fake.findReportByVetOrgReturnsOnCall[i] = struct {
		result1 []model.DiagnosticReport
		result2 error
	}{result1, result2}
}

func (fake *FakeDiagnosticReportService) FindReportByUser(ctx context.Context, user model.User) ([]model.DiagnosticReport, error) {
	fake.findReportByUserMutex.Lock()
	ret, specificReturn := fake.findReportByUserReturnsOnCall[len(fake.findReportByUserArgsForCall)]
	fake.findReportByUserArgsForCall = append(fake.findReportByUserArgsForCall, struct {
		ctx  context.Context
		user model.User
	}{ctx, user})
	fake.recordInvocation("FindReportByUser", []interface{}{ctx, user})
	fake.findReportByUserMutex.Unlock()
	if fake.FindReportByUserStub != nil {
		return fake.FindReportByUserStub(ctx, user)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.findReportByUserReturns.result1, fake.findReportByUserReturns.result2
}

func (fake *FakeDiagnosticReportService) FindReportByUserCallCount() int {
	fake.findReportByUserMutex.RLock()
	defer fake.findReportByUserMutex.RUnlock()
	return len(fake.findReportByUserArgsForCall)
}

func (fake *FakeDiagnosticReportService) FindReportByUserArgsForCall(i int) (context.Context, model.User) {
	fake.findReportByUserMutex.RLock()
	defer fake.findReportByUserMutex.RUnlock()
	return fake.findReportByUserArgsForCall[i].ctx, fake.findReportByUserArgsForCall[i].user
}

func (fake *FakeDiagnosticReportService) FindReportByUserReturns(result1 []model.DiagnosticReport, result2 error) {
	fake.FindReportByUserStub = nil
	fake.findReportByUserReturns = struct {
		result1 []model.DiagnosticReport
		result2 error
	}{result1, result2}
}

func (fake *FakeDiagnosticReportService) FindReportByUserReturnsOnCall(i int, result1 []model.DiagnosticReport, result2 error) {
	fake.FindReportByUserStub = nil
	if fake.findReportByUserReturnsOnCall == nil {
		fake.findReportByUserReturnsOnCall = make(map[int]struct {
			result1 []model.DiagnosticReport
			result2 error
		})
	}
	fake.findReportByUserReturnsOnCall[i] = struct {
		result1 []model.DiagnosticReport
		result2 error
	}{result1, result2}
}

func (fake *FakeDiagnosticReportService) FindReportByCustomer(ctx context.Context, customer model.Customer) ([]model.DiagnosticReport, error) {
	fake.findReportByCustomerMutex.Lock()
	ret, specificReturn := fake.findReportByCustomerReturnsOnCall[len(fake.findReportByCustomerArgsForCall)]
	fake.findReportByCustomerArgsForCall = append(fake.findReportByCustomerArgsForCall, struct {
		ctx      context.Context
		customer model.Customer
	}{ctx, customer})
	fake.recordInvocation("FindReportByCustomer", []interface{}{ctx, customer})
	fake.findReportByCustomerMutex.Unlock()
	if fake.FindReportByCustomerStub != nil {
		return fake.FindReportByCustomerStub(ctx, customer)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.findReportByCustomerReturns.result1, fake.findReportByCustomerReturns.result2
}

func (fake *FakeDiagnosticReportService) FindReportByCustomerCallCount() int {
	fake.findReportByCustomerMutex.RLock()
	defer fake.findReportByCustomerMutex.RUnlock()
	return len(fake.findReportByCustomerArgsForCall)
}

func (fake *FakeDiagnosticReportService) FindReportByCustomerArgsForCall(i int) (context.Context, model.Customer) {
	fake.findReportByCustomerMutex.RLock()
	defer fake.findReportByCustomerMutex.RUnlock()
	return fake.findReportByCustomerArgsForCall[i].ctx, fake.findReportByCustomerArgsForCall[i].customer
}

func (fake *FakeDiagnosticReportService) FindReportByCustomerReturns(result1 []model.DiagnosticReport, result2 error) {
	fake.FindReportByCustomerStub = nil
	fake.findReportByCustomerReturns = struct {
		result1 []model.DiagnosticReport
		result2 error
	}{result1, result2}
}

func (fake *FakeDiagnosticReportService) FindReportByCustomerReturnsOnCall(i int, result1 []model.DiagnosticReport, result2 error) {
	fake.FindReportByCustomerStub = nil
	if fake.findReportByCustomerReturnsOnCall == nil {
		fake.findReportByCustomerReturnsOnCall = make(map[int]struct {
			result1 []model.DiagnosticReport
			result2 error
		})
	}
	fake.findReportByCustomerReturnsOnCall[i] = struct {
		result1 []model.DiagnosticReport
		result2 error
	}{result1, result2}
}

func (fake *FakeDiagnosticReportService) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.sumbmitDiagnosticReportMutex.RLock()
	defer fake.sumbmitDiagnosticReportMutex.RUnlock()
	fake.findReportByDateRangeMutex.RLock()
	defer fake.findReportByDateRangeMutex.RUnlock()
	fake.findReportByIDMutex.RLock()
	defer fake.findReportByIDMutex.RUnlock()
	fake.findReportByVetOrgMutex.RLock()
	defer fake.findReportByVetOrgMutex.RUnlock()
	fake.findReportByUserMutex.RLock()
	defer fake.findReportByUserMutex.RUnlock()
	fake.findReportByCustomerMutex.RLock()
	defer fake.findReportByCustomerMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeDiagnosticReportService) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ api.DiagnosticReportService = new(FakeDiagnosticReportService)
