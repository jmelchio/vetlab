// Code generated by counterfeiter. DO NOT EDIT.
package apifakes

import (
	"context"
	"sync"
	"time"

	"github.com/jmelchio/vetlab/api"
	"github.com/jmelchio/vetlab/model"
)

type FakeDiagnosticReportService struct {
	FindReportByCustomerStub        func(context.Context, model.Customer) ([]model.DiagnosticReport, error)
	findReportByCustomerMutex       sync.RWMutex
	findReportByCustomerArgsForCall []struct {
		arg1 context.Context
		arg2 model.Customer
	}
	findReportByCustomerReturns struct {
		result1 []model.DiagnosticReport
		result2 error
	}
	findReportByCustomerReturnsOnCall map[int]struct {
		result1 []model.DiagnosticReport
		result2 error
	}
	FindReportByDateRangeStub        func(context.Context, time.Time, time.Time, model.VetOrg) ([]model.DiagnosticReport, error)
	findReportByDateRangeMutex       sync.RWMutex
	findReportByDateRangeArgsForCall []struct {
		arg1 context.Context
		arg2 time.Time
		arg3 time.Time
		arg4 model.VetOrg
	}
	findReportByDateRangeReturns struct {
		result1 []model.DiagnosticReport
		result2 error
	}
	findReportByDateRangeReturnsOnCall map[int]struct {
		result1 []model.DiagnosticReport
		result2 error
	}
	FindReportByIDStub        func(context.Context, uint) (*model.DiagnosticReport, error)
	findReportByIDMutex       sync.RWMutex
	findReportByIDArgsForCall []struct {
		arg1 context.Context
		arg2 uint
	}
	findReportByIDReturns struct {
		result1 *model.DiagnosticReport
		result2 error
	}
	findReportByIDReturnsOnCall map[int]struct {
		result1 *model.DiagnosticReport
		result2 error
	}
	FindReportByUserStub        func(context.Context, model.User) ([]model.DiagnosticReport, error)
	findReportByUserMutex       sync.RWMutex
	findReportByUserArgsForCall []struct {
		arg1 context.Context
		arg2 model.User
	}
	findReportByUserReturns struct {
		result1 []model.DiagnosticReport
		result2 error
	}
	findReportByUserReturnsOnCall map[int]struct {
		result1 []model.DiagnosticReport
		result2 error
	}
	FindReportByVetOrgStub        func(context.Context, model.VetOrg) ([]model.DiagnosticReport, error)
	findReportByVetOrgMutex       sync.RWMutex
	findReportByVetOrgArgsForCall []struct {
		arg1 context.Context
		arg2 model.VetOrg
	}
	findReportByVetOrgReturns struct {
		result1 []model.DiagnosticReport
		result2 error
	}
	findReportByVetOrgReturnsOnCall map[int]struct {
		result1 []model.DiagnosticReport
		result2 error
	}
	SubmitDiagnosticReportStub        func(context.Context, model.DiagnosticReport) (*model.DiagnosticReport, error)
	submitDiagnosticReportMutex       sync.RWMutex
	submitDiagnosticReportArgsForCall []struct {
		arg1 context.Context
		arg2 model.DiagnosticReport
	}
	submitDiagnosticReportReturns struct {
		result1 *model.DiagnosticReport
		result2 error
	}
	submitDiagnosticReportReturnsOnCall map[int]struct {
		result1 *model.DiagnosticReport
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeDiagnosticReportService) FindReportByCustomer(arg1 context.Context, arg2 model.Customer) ([]model.DiagnosticReport, error) {
	fake.findReportByCustomerMutex.Lock()
	ret, specificReturn := fake.findReportByCustomerReturnsOnCall[len(fake.findReportByCustomerArgsForCall)]
	fake.findReportByCustomerArgsForCall = append(fake.findReportByCustomerArgsForCall, struct {
		arg1 context.Context
		arg2 model.Customer
	}{arg1, arg2})
	stub := fake.FindReportByCustomerStub
	fakeReturns := fake.findReportByCustomerReturns
	fake.recordInvocation("FindReportByCustomer", []interface{}{arg1, arg2})
	fake.findReportByCustomerMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDiagnosticReportService) FindReportByCustomerCallCount() int {
	fake.findReportByCustomerMutex.RLock()
	defer fake.findReportByCustomerMutex.RUnlock()
	return len(fake.findReportByCustomerArgsForCall)
}

func (fake *FakeDiagnosticReportService) FindReportByCustomerCalls(stub func(context.Context, model.Customer) ([]model.DiagnosticReport, error)) {
	fake.findReportByCustomerMutex.Lock()
	defer fake.findReportByCustomerMutex.Unlock()
	fake.FindReportByCustomerStub = stub
}

func (fake *FakeDiagnosticReportService) FindReportByCustomerArgsForCall(i int) (context.Context, model.Customer) {
	fake.findReportByCustomerMutex.RLock()
	defer fake.findReportByCustomerMutex.RUnlock()
	argsForCall := fake.findReportByCustomerArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeDiagnosticReportService) FindReportByCustomerReturns(result1 []model.DiagnosticReport, result2 error) {
	fake.findReportByCustomerMutex.Lock()
	defer fake.findReportByCustomerMutex.Unlock()
	fake.FindReportByCustomerStub = nil
	fake.findReportByCustomerReturns = struct {
		result1 []model.DiagnosticReport
		result2 error
	}{result1, result2}
}

func (fake *FakeDiagnosticReportService) FindReportByCustomerReturnsOnCall(i int, result1 []model.DiagnosticReport, result2 error) {
	fake.findReportByCustomerMutex.Lock()
	defer fake.findReportByCustomerMutex.Unlock()
	fake.FindReportByCustomerStub = nil
	if fake.findReportByCustomerReturnsOnCall == nil {
		fake.findReportByCustomerReturnsOnCall = make(map[int]struct {
			result1 []model.DiagnosticReport
			result2 error
		})
	}
	fake.findReportByCustomerReturnsOnCall[i] = struct {
		result1 []model.DiagnosticReport
		result2 error
	}{result1, result2}
}

func (fake *FakeDiagnosticReportService) FindReportByDateRange(arg1 context.Context, arg2 time.Time, arg3 time.Time, arg4 model.VetOrg) ([]model.DiagnosticReport, error) {
	fake.findReportByDateRangeMutex.Lock()
	ret, specificReturn := fake.findReportByDateRangeReturnsOnCall[len(fake.findReportByDateRangeArgsForCall)]
	fake.findReportByDateRangeArgsForCall = append(fake.findReportByDateRangeArgsForCall, struct {
		arg1 context.Context
		arg2 time.Time
		arg3 time.Time
		arg4 model.VetOrg
	}{arg1, arg2, arg3, arg4})
	stub := fake.FindReportByDateRangeStub
	fakeReturns := fake.findReportByDateRangeReturns
	fake.recordInvocation("FindReportByDateRange", []interface{}{arg1, arg2, arg3, arg4})
	fake.findReportByDateRangeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDiagnosticReportService) FindReportByDateRangeCallCount() int {
	fake.findReportByDateRangeMutex.RLock()
	defer fake.findReportByDateRangeMutex.RUnlock()
	return len(fake.findReportByDateRangeArgsForCall)
}

func (fake *FakeDiagnosticReportService) FindReportByDateRangeCalls(stub func(context.Context, time.Time, time.Time, model.VetOrg) ([]model.DiagnosticReport, error)) {
	fake.findReportByDateRangeMutex.Lock()
	defer fake.findReportByDateRangeMutex.Unlock()
	fake.FindReportByDateRangeStub = stub
}

func (fake *FakeDiagnosticReportService) FindReportByDateRangeArgsForCall(i int) (context.Context, time.Time, time.Time, model.VetOrg) {
	fake.findReportByDateRangeMutex.RLock()
	defer fake.findReportByDateRangeMutex.RUnlock()
	argsForCall := fake.findReportByDateRangeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeDiagnosticReportService) FindReportByDateRangeReturns(result1 []model.DiagnosticReport, result2 error) {
	fake.findReportByDateRangeMutex.Lock()
	defer fake.findReportByDateRangeMutex.Unlock()
	fake.FindReportByDateRangeStub = nil
	fake.findReportByDateRangeReturns = struct {
		result1 []model.DiagnosticReport
		result2 error
	}{result1, result2}
}

func (fake *FakeDiagnosticReportService) FindReportByDateRangeReturnsOnCall(i int, result1 []model.DiagnosticReport, result2 error) {
	fake.findReportByDateRangeMutex.Lock()
	defer fake.findReportByDateRangeMutex.Unlock()
	fake.FindReportByDateRangeStub = nil
	if fake.findReportByDateRangeReturnsOnCall == nil {
		fake.findReportByDateRangeReturnsOnCall = make(map[int]struct {
			result1 []model.DiagnosticReport
			result2 error
		})
	}
	fake.findReportByDateRangeReturnsOnCall[i] = struct {
		result1 []model.DiagnosticReport
		result2 error
	}{result1, result2}
}

func (fake *FakeDiagnosticReportService) FindReportByID(arg1 context.Context, arg2 uint) (*model.DiagnosticReport, error) {
	fake.findReportByIDMutex.Lock()
	ret, specificReturn := fake.findReportByIDReturnsOnCall[len(fake.findReportByIDArgsForCall)]
	fake.findReportByIDArgsForCall = append(fake.findReportByIDArgsForCall, struct {
		arg1 context.Context
		arg2 uint
	}{arg1, arg2})
	stub := fake.FindReportByIDStub
	fakeReturns := fake.findReportByIDReturns
	fake.recordInvocation("FindReportByID", []interface{}{arg1, arg2})
	fake.findReportByIDMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDiagnosticReportService) FindReportByIDCallCount() int {
	fake.findReportByIDMutex.RLock()
	defer fake.findReportByIDMutex.RUnlock()
	return len(fake.findReportByIDArgsForCall)
}

func (fake *FakeDiagnosticReportService) FindReportByIDCalls(stub func(context.Context, uint) (*model.DiagnosticReport, error)) {
	fake.findReportByIDMutex.Lock()
	defer fake.findReportByIDMutex.Unlock()
	fake.FindReportByIDStub = stub
}

func (fake *FakeDiagnosticReportService) FindReportByIDArgsForCall(i int) (context.Context, uint) {
	fake.findReportByIDMutex.RLock()
	defer fake.findReportByIDMutex.RUnlock()
	argsForCall := fake.findReportByIDArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeDiagnosticReportService) FindReportByIDReturns(result1 *model.DiagnosticReport, result2 error) {
	fake.findReportByIDMutex.Lock()
	defer fake.findReportByIDMutex.Unlock()
	fake.FindReportByIDStub = nil
	fake.findReportByIDReturns = struct {
		result1 *model.DiagnosticReport
		result2 error
	}{result1, result2}
}

func (fake *FakeDiagnosticReportService) FindReportByIDReturnsOnCall(i int, result1 *model.DiagnosticReport, result2 error) {
	fake.findReportByIDMutex.Lock()
	defer fake.findReportByIDMutex.Unlock()
	fake.FindReportByIDStub = nil
	if fake.findReportByIDReturnsOnCall == nil {
		fake.findReportByIDReturnsOnCall = make(map[int]struct {
			result1 *model.DiagnosticReport
			result2 error
		})
	}
	fake.findReportByIDReturnsOnCall[i] = struct {
		result1 *model.DiagnosticReport
		result2 error
	}{result1, result2}
}

func (fake *FakeDiagnosticReportService) FindReportByUser(arg1 context.Context, arg2 model.User) ([]model.DiagnosticReport, error) {
	fake.findReportByUserMutex.Lock()
	ret, specificReturn := fake.findReportByUserReturnsOnCall[len(fake.findReportByUserArgsForCall)]
	fake.findReportByUserArgsForCall = append(fake.findReportByUserArgsForCall, struct {
		arg1 context.Context
		arg2 model.User
	}{arg1, arg2})
	stub := fake.FindReportByUserStub
	fakeReturns := fake.findReportByUserReturns
	fake.recordInvocation("FindReportByUser", []interface{}{arg1, arg2})
	fake.findReportByUserMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDiagnosticReportService) FindReportByUserCallCount() int {
	fake.findReportByUserMutex.RLock()
	defer fake.findReportByUserMutex.RUnlock()
	return len(fake.findReportByUserArgsForCall)
}

func (fake *FakeDiagnosticReportService) FindReportByUserCalls(stub func(context.Context, model.User) ([]model.DiagnosticReport, error)) {
	fake.findReportByUserMutex.Lock()
	defer fake.findReportByUserMutex.Unlock()
	fake.FindReportByUserStub = stub
}

func (fake *FakeDiagnosticReportService) FindReportByUserArgsForCall(i int) (context.Context, model.User) {
	fake.findReportByUserMutex.RLock()
	defer fake.findReportByUserMutex.RUnlock()
	argsForCall := fake.findReportByUserArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeDiagnosticReportService) FindReportByUserReturns(result1 []model.DiagnosticReport, result2 error) {
	fake.findReportByUserMutex.Lock()
	defer fake.findReportByUserMutex.Unlock()
	fake.FindReportByUserStub = nil
	fake.findReportByUserReturns = struct {
		result1 []model.DiagnosticReport
		result2 error
	}{result1, result2}
}

func (fake *FakeDiagnosticReportService) FindReportByUserReturnsOnCall(i int, result1 []model.DiagnosticReport, result2 error) {
	fake.findReportByUserMutex.Lock()
	defer fake.findReportByUserMutex.Unlock()
	fake.FindReportByUserStub = nil
	if fake.findReportByUserReturnsOnCall == nil {
		fake.findReportByUserReturnsOnCall = make(map[int]struct {
			result1 []model.DiagnosticReport
			result2 error
		})
	}
	fake.findReportByUserReturnsOnCall[i] = struct {
		result1 []model.DiagnosticReport
		result2 error
	}{result1, result2}
}

func (fake *FakeDiagnosticReportService) FindReportByVetOrg(arg1 context.Context, arg2 model.VetOrg) ([]model.DiagnosticReport, error) {
	fake.findReportByVetOrgMutex.Lock()
	ret, specificReturn := fake.findReportByVetOrgReturnsOnCall[len(fake.findReportByVetOrgArgsForCall)]
	fake.findReportByVetOrgArgsForCall = append(fake.findReportByVetOrgArgsForCall, struct {
		arg1 context.Context
		arg2 model.VetOrg
	}{arg1, arg2})
	stub := fake.FindReportByVetOrgStub
	fakeReturns := fake.findReportByVetOrgReturns
	fake.recordInvocation("FindReportByVetOrg", []interface{}{arg1, arg2})
	fake.findReportByVetOrgMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDiagnosticReportService) FindReportByVetOrgCallCount() int {
	fake.findReportByVetOrgMutex.RLock()
	defer fake.findReportByVetOrgMutex.RUnlock()
	return len(fake.findReportByVetOrgArgsForCall)
}

func (fake *FakeDiagnosticReportService) FindReportByVetOrgCalls(stub func(context.Context, model.VetOrg) ([]model.DiagnosticReport, error)) {
	fake.findReportByVetOrgMutex.Lock()
	defer fake.findReportByVetOrgMutex.Unlock()
	fake.FindReportByVetOrgStub = stub
}

func (fake *FakeDiagnosticReportService) FindReportByVetOrgArgsForCall(i int) (context.Context, model.VetOrg) {
	fake.findReportByVetOrgMutex.RLock()
	defer fake.findReportByVetOrgMutex.RUnlock()
	argsForCall := fake.findReportByVetOrgArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeDiagnosticReportService) FindReportByVetOrgReturns(result1 []model.DiagnosticReport, result2 error) {
	fake.findReportByVetOrgMutex.Lock()
	defer fake.findReportByVetOrgMutex.Unlock()
	fake.FindReportByVetOrgStub = nil
	fake.findReportByVetOrgReturns = struct {
		result1 []model.DiagnosticReport
		result2 error
	}{result1, result2}
}

func (fake *FakeDiagnosticReportService) FindReportByVetOrgReturnsOnCall(i int, result1 []model.DiagnosticReport, result2 error) {
	fake.findReportByVetOrgMutex.Lock()
	defer fake.findReportByVetOrgMutex.Unlock()
	fake.FindReportByVetOrgStub = nil
	if fake.findReportByVetOrgReturnsOnCall == nil {
		fake.findReportByVetOrgReturnsOnCall = make(map[int]struct {
			result1 []model.DiagnosticReport
			result2 error
		})
	}
	fake.findReportByVetOrgReturnsOnCall[i] = struct {
		result1 []model.DiagnosticReport
		result2 error
	}{result1, result2}
}

func (fake *FakeDiagnosticReportService) SubmitDiagnosticReport(arg1 context.Context, arg2 model.DiagnosticReport) (*model.DiagnosticReport, error) {
	fake.submitDiagnosticReportMutex.Lock()
	ret, specificReturn := fake.submitDiagnosticReportReturnsOnCall[len(fake.submitDiagnosticReportArgsForCall)]
	fake.submitDiagnosticReportArgsForCall = append(fake.submitDiagnosticReportArgsForCall, struct {
		arg1 context.Context
		arg2 model.DiagnosticReport
	}{arg1, arg2})
	stub := fake.SubmitDiagnosticReportStub
	fakeReturns := fake.submitDiagnosticReportReturns
	fake.recordInvocation("SubmitDiagnosticReport", []interface{}{arg1, arg2})
	fake.submitDiagnosticReportMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDiagnosticReportService) SubmitDiagnosticReportCallCount() int {
	fake.submitDiagnosticReportMutex.RLock()
	defer fake.submitDiagnosticReportMutex.RUnlock()
	return len(fake.submitDiagnosticReportArgsForCall)
}

func (fake *FakeDiagnosticReportService) SubmitDiagnosticReportCalls(stub func(context.Context, model.DiagnosticReport) (*model.DiagnosticReport, error)) {
	fake.submitDiagnosticReportMutex.Lock()
	defer fake.submitDiagnosticReportMutex.Unlock()
	fake.SubmitDiagnosticReportStub = stub
}

func (fake *FakeDiagnosticReportService) SubmitDiagnosticReportArgsForCall(i int) (context.Context, model.DiagnosticReport) {
	fake.submitDiagnosticReportMutex.RLock()
	defer fake.submitDiagnosticReportMutex.RUnlock()
	argsForCall := fake.submitDiagnosticReportArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeDiagnosticReportService) SubmitDiagnosticReportReturns(result1 *model.DiagnosticReport, result2 error) {
	fake.submitDiagnosticReportMutex.Lock()
	defer fake.submitDiagnosticReportMutex.Unlock()
	fake.SubmitDiagnosticReportStub = nil
	fake.submitDiagnosticReportReturns = struct {
		result1 *model.DiagnosticReport
		result2 error
	}{result1, result2}
}

func (fake *FakeDiagnosticReportService) SubmitDiagnosticReportReturnsOnCall(i int, result1 *model.DiagnosticReport, result2 error) {
	fake.submitDiagnosticReportMutex.Lock()
	defer fake.submitDiagnosticReportMutex.Unlock()
	fake.SubmitDiagnosticReportStub = nil
	if fake.submitDiagnosticReportReturnsOnCall == nil {
		fake.submitDiagnosticReportReturnsOnCall = make(map[int]struct {
			result1 *model.DiagnosticReport
			result2 error
		})
	}
	fake.submitDiagnosticReportReturnsOnCall[i] = struct {
		result1 *model.DiagnosticReport
		result2 error
	}{result1, result2}
}

func (fake *FakeDiagnosticReportService) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.findReportByCustomerMutex.RLock()
	defer fake.findReportByCustomerMutex.RUnlock()
	fake.findReportByDateRangeMutex.RLock()
	defer fake.findReportByDateRangeMutex.RUnlock()
	fake.findReportByIDMutex.RLock()
	defer fake.findReportByIDMutex.RUnlock()
	fake.findReportByUserMutex.RLock()
	defer fake.findReportByUserMutex.RUnlock()
	fake.findReportByVetOrgMutex.RLock()
	defer fake.findReportByVetOrgMutex.RUnlock()
	fake.submitDiagnosticReportMutex.RLock()
	defer fake.submitDiagnosticReportMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeDiagnosticReportService) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ api.DiagnosticReportService = new(FakeDiagnosticReportService)
