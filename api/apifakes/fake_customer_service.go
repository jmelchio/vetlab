// Code generated by counterfeiter. DO NOT EDIT.
package apifakes

import (
	"context"
	"sync"

	"github.com/jmelchio/vetlab/api"
	"github.com/jmelchio/vetlab/model"
)

type FakeCustomerService struct {
	CreateCustomerStub        func(context.Context, model.Customer) (*model.Customer, error)
	createCustomerMutex       sync.RWMutex
	createCustomerArgsForCall []struct {
		arg1 context.Context
		arg2 model.Customer
	}
	createCustomerReturns struct {
		result1 *model.Customer
		result2 error
	}
	createCustomerReturnsOnCall map[int]struct {
		result1 *model.Customer
		result2 error
	}
	DeleteCustomerStub        func(context.Context, model.Customer) error
	deleteCustomerMutex       sync.RWMutex
	deleteCustomerArgsForCall []struct {
		arg1 context.Context
		arg2 model.Customer
	}
	deleteCustomerReturns struct {
		result1 error
	}
	deleteCustomerReturnsOnCall map[int]struct {
		result1 error
	}
	FindCustomerByIDStub        func(context.Context, uint) (*model.Customer, error)
	findCustomerByIDMutex       sync.RWMutex
	findCustomerByIDArgsForCall []struct {
		arg1 context.Context
		arg2 uint
	}
	findCustomerByIDReturns struct {
		result1 *model.Customer
		result2 error
	}
	findCustomerByIDReturnsOnCall map[int]struct {
		result1 *model.Customer
		result2 error
	}
	FindCustomerByUserNameStub        func(context.Context, string) (*model.Customer, error)
	findCustomerByUserNameMutex       sync.RWMutex
	findCustomerByUserNameArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	findCustomerByUserNameReturns struct {
		result1 *model.Customer
		result2 error
	}
	findCustomerByUserNameReturnsOnCall map[int]struct {
		result1 *model.Customer
		result2 error
	}
	FindCustomerByVetOrgStub        func(context.Context, model.VetOrg) ([]model.Customer, error)
	findCustomerByVetOrgMutex       sync.RWMutex
	findCustomerByVetOrgArgsForCall []struct {
		arg1 context.Context
		arg2 model.VetOrg
	}
	findCustomerByVetOrgReturns struct {
		result1 []model.Customer
		result2 error
	}
	findCustomerByVetOrgReturnsOnCall map[int]struct {
		result1 []model.Customer
		result2 error
	}
	LoginStub        func(context.Context, string, string) (*model.Customer, error)
	loginMutex       sync.RWMutex
	loginArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	loginReturns struct {
		result1 *model.Customer
		result2 error
	}
	loginReturnsOnCall map[int]struct {
		result1 *model.Customer
		result2 error
	}
	UpdateCustomerStub        func(context.Context, model.Customer) (*model.Customer, error)
	updateCustomerMutex       sync.RWMutex
	updateCustomerArgsForCall []struct {
		arg1 context.Context
		arg2 model.Customer
	}
	updateCustomerReturns struct {
		result1 *model.Customer
		result2 error
	}
	updateCustomerReturnsOnCall map[int]struct {
		result1 *model.Customer
		result2 error
	}
	UpdatePasswordStub        func(context.Context, model.Customer, string) (*model.Customer, error)
	updatePasswordMutex       sync.RWMutex
	updatePasswordArgsForCall []struct {
		arg1 context.Context
		arg2 model.Customer
		arg3 string
	}
	updatePasswordReturns struct {
		result1 *model.Customer
		result2 error
	}
	updatePasswordReturnsOnCall map[int]struct {
		result1 *model.Customer
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeCustomerService) CreateCustomer(arg1 context.Context, arg2 model.Customer) (*model.Customer, error) {
	fake.createCustomerMutex.Lock()
	ret, specificReturn := fake.createCustomerReturnsOnCall[len(fake.createCustomerArgsForCall)]
	fake.createCustomerArgsForCall = append(fake.createCustomerArgsForCall, struct {
		arg1 context.Context
		arg2 model.Customer
	}{arg1, arg2})
	stub := fake.CreateCustomerStub
	fakeReturns := fake.createCustomerReturns
	fake.recordInvocation("CreateCustomer", []interface{}{arg1, arg2})
	fake.createCustomerMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeCustomerService) CreateCustomerCallCount() int {
	fake.createCustomerMutex.RLock()
	defer fake.createCustomerMutex.RUnlock()
	return len(fake.createCustomerArgsForCall)
}

func (fake *FakeCustomerService) CreateCustomerCalls(stub func(context.Context, model.Customer) (*model.Customer, error)) {
	fake.createCustomerMutex.Lock()
	defer fake.createCustomerMutex.Unlock()
	fake.CreateCustomerStub = stub
}

func (fake *FakeCustomerService) CreateCustomerArgsForCall(i int) (context.Context, model.Customer) {
	fake.createCustomerMutex.RLock()
	defer fake.createCustomerMutex.RUnlock()
	argsForCall := fake.createCustomerArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeCustomerService) CreateCustomerReturns(result1 *model.Customer, result2 error) {
	fake.createCustomerMutex.Lock()
	defer fake.createCustomerMutex.Unlock()
	fake.CreateCustomerStub = nil
	fake.createCustomerReturns = struct {
		result1 *model.Customer
		result2 error
	}{result1, result2}
}

func (fake *FakeCustomerService) CreateCustomerReturnsOnCall(i int, result1 *model.Customer, result2 error) {
	fake.createCustomerMutex.Lock()
	defer fake.createCustomerMutex.Unlock()
	fake.CreateCustomerStub = nil
	if fake.createCustomerReturnsOnCall == nil {
		fake.createCustomerReturnsOnCall = make(map[int]struct {
			result1 *model.Customer
			result2 error
		})
	}
	fake.createCustomerReturnsOnCall[i] = struct {
		result1 *model.Customer
		result2 error
	}{result1, result2}
}

func (fake *FakeCustomerService) DeleteCustomer(arg1 context.Context, arg2 model.Customer) error {
	fake.deleteCustomerMutex.Lock()
	ret, specificReturn := fake.deleteCustomerReturnsOnCall[len(fake.deleteCustomerArgsForCall)]
	fake.deleteCustomerArgsForCall = append(fake.deleteCustomerArgsForCall, struct {
		arg1 context.Context
		arg2 model.Customer
	}{arg1, arg2})
	stub := fake.DeleteCustomerStub
	fakeReturns := fake.deleteCustomerReturns
	fake.recordInvocation("DeleteCustomer", []interface{}{arg1, arg2})
	fake.deleteCustomerMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeCustomerService) DeleteCustomerCallCount() int {
	fake.deleteCustomerMutex.RLock()
	defer fake.deleteCustomerMutex.RUnlock()
	return len(fake.deleteCustomerArgsForCall)
}

func (fake *FakeCustomerService) DeleteCustomerCalls(stub func(context.Context, model.Customer) error) {
	fake.deleteCustomerMutex.Lock()
	defer fake.deleteCustomerMutex.Unlock()
	fake.DeleteCustomerStub = stub
}

func (fake *FakeCustomerService) DeleteCustomerArgsForCall(i int) (context.Context, model.Customer) {
	fake.deleteCustomerMutex.RLock()
	defer fake.deleteCustomerMutex.RUnlock()
	argsForCall := fake.deleteCustomerArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeCustomerService) DeleteCustomerReturns(result1 error) {
	fake.deleteCustomerMutex.Lock()
	defer fake.deleteCustomerMutex.Unlock()
	fake.DeleteCustomerStub = nil
	fake.deleteCustomerReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeCustomerService) DeleteCustomerReturnsOnCall(i int, result1 error) {
	fake.deleteCustomerMutex.Lock()
	defer fake.deleteCustomerMutex.Unlock()
	fake.DeleteCustomerStub = nil
	if fake.deleteCustomerReturnsOnCall == nil {
		fake.deleteCustomerReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteCustomerReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeCustomerService) FindCustomerByID(arg1 context.Context, arg2 uint) (*model.Customer, error) {
	fake.findCustomerByIDMutex.Lock()
	ret, specificReturn := fake.findCustomerByIDReturnsOnCall[len(fake.findCustomerByIDArgsForCall)]
	fake.findCustomerByIDArgsForCall = append(fake.findCustomerByIDArgsForCall, struct {
		arg1 context.Context
		arg2 uint
	}{arg1, arg2})
	stub := fake.FindCustomerByIDStub
	fakeReturns := fake.findCustomerByIDReturns
	fake.recordInvocation("FindCustomerByID", []interface{}{arg1, arg2})
	fake.findCustomerByIDMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeCustomerService) FindCustomerByIDCallCount() int {
	fake.findCustomerByIDMutex.RLock()
	defer fake.findCustomerByIDMutex.RUnlock()
	return len(fake.findCustomerByIDArgsForCall)
}

func (fake *FakeCustomerService) FindCustomerByIDCalls(stub func(context.Context, uint) (*model.Customer, error)) {
	fake.findCustomerByIDMutex.Lock()
	defer fake.findCustomerByIDMutex.Unlock()
	fake.FindCustomerByIDStub = stub
}

func (fake *FakeCustomerService) FindCustomerByIDArgsForCall(i int) (context.Context, uint) {
	fake.findCustomerByIDMutex.RLock()
	defer fake.findCustomerByIDMutex.RUnlock()
	argsForCall := fake.findCustomerByIDArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeCustomerService) FindCustomerByIDReturns(result1 *model.Customer, result2 error) {
	fake.findCustomerByIDMutex.Lock()
	defer fake.findCustomerByIDMutex.Unlock()
	fake.FindCustomerByIDStub = nil
	fake.findCustomerByIDReturns = struct {
		result1 *model.Customer
		result2 error
	}{result1, result2}
}

func (fake *FakeCustomerService) FindCustomerByIDReturnsOnCall(i int, result1 *model.Customer, result2 error) {
	fake.findCustomerByIDMutex.Lock()
	defer fake.findCustomerByIDMutex.Unlock()
	fake.FindCustomerByIDStub = nil
	if fake.findCustomerByIDReturnsOnCall == nil {
		fake.findCustomerByIDReturnsOnCall = make(map[int]struct {
			result1 *model.Customer
			result2 error
		})
	}
	fake.findCustomerByIDReturnsOnCall[i] = struct {
		result1 *model.Customer
		result2 error
	}{result1, result2}
}

func (fake *FakeCustomerService) FindCustomerByUserName(arg1 context.Context, arg2 string) (*model.Customer, error) {
	fake.findCustomerByUserNameMutex.Lock()
	ret, specificReturn := fake.findCustomerByUserNameReturnsOnCall[len(fake.findCustomerByUserNameArgsForCall)]
	fake.findCustomerByUserNameArgsForCall = append(fake.findCustomerByUserNameArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.FindCustomerByUserNameStub
	fakeReturns := fake.findCustomerByUserNameReturns
	fake.recordInvocation("FindCustomerByUserName", []interface{}{arg1, arg2})
	fake.findCustomerByUserNameMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeCustomerService) FindCustomerByUserNameCallCount() int {
	fake.findCustomerByUserNameMutex.RLock()
	defer fake.findCustomerByUserNameMutex.RUnlock()
	return len(fake.findCustomerByUserNameArgsForCall)
}

func (fake *FakeCustomerService) FindCustomerByUserNameCalls(stub func(context.Context, string) (*model.Customer, error)) {
	fake.findCustomerByUserNameMutex.Lock()
	defer fake.findCustomerByUserNameMutex.Unlock()
	fake.FindCustomerByUserNameStub = stub
}

func (fake *FakeCustomerService) FindCustomerByUserNameArgsForCall(i int) (context.Context, string) {
	fake.findCustomerByUserNameMutex.RLock()
	defer fake.findCustomerByUserNameMutex.RUnlock()
	argsForCall := fake.findCustomerByUserNameArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeCustomerService) FindCustomerByUserNameReturns(result1 *model.Customer, result2 error) {
	fake.findCustomerByUserNameMutex.Lock()
	defer fake.findCustomerByUserNameMutex.Unlock()
	fake.FindCustomerByUserNameStub = nil
	fake.findCustomerByUserNameReturns = struct {
		result1 *model.Customer
		result2 error
	}{result1, result2}
}

func (fake *FakeCustomerService) FindCustomerByUserNameReturnsOnCall(i int, result1 *model.Customer, result2 error) {
	fake.findCustomerByUserNameMutex.Lock()
	defer fake.findCustomerByUserNameMutex.Unlock()
	fake.FindCustomerByUserNameStub = nil
	if fake.findCustomerByUserNameReturnsOnCall == nil {
		fake.findCustomerByUserNameReturnsOnCall = make(map[int]struct {
			result1 *model.Customer
			result2 error
		})
	}
	fake.findCustomerByUserNameReturnsOnCall[i] = struct {
		result1 *model.Customer
		result2 error
	}{result1, result2}
}

func (fake *FakeCustomerService) FindCustomerByVetOrg(arg1 context.Context, arg2 model.VetOrg) ([]model.Customer, error) {
	fake.findCustomerByVetOrgMutex.Lock()
	ret, specificReturn := fake.findCustomerByVetOrgReturnsOnCall[len(fake.findCustomerByVetOrgArgsForCall)]
	fake.findCustomerByVetOrgArgsForCall = append(fake.findCustomerByVetOrgArgsForCall, struct {
		arg1 context.Context
		arg2 model.VetOrg
	}{arg1, arg2})
	stub := fake.FindCustomerByVetOrgStub
	fakeReturns := fake.findCustomerByVetOrgReturns
	fake.recordInvocation("FindCustomerByVetOrg", []interface{}{arg1, arg2})
	fake.findCustomerByVetOrgMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeCustomerService) FindCustomerByVetOrgCallCount() int {
	fake.findCustomerByVetOrgMutex.RLock()
	defer fake.findCustomerByVetOrgMutex.RUnlock()
	return len(fake.findCustomerByVetOrgArgsForCall)
}

func (fake *FakeCustomerService) FindCustomerByVetOrgCalls(stub func(context.Context, model.VetOrg) ([]model.Customer, error)) {
	fake.findCustomerByVetOrgMutex.Lock()
	defer fake.findCustomerByVetOrgMutex.Unlock()
	fake.FindCustomerByVetOrgStub = stub
}

func (fake *FakeCustomerService) FindCustomerByVetOrgArgsForCall(i int) (context.Context, model.VetOrg) {
	fake.findCustomerByVetOrgMutex.RLock()
	defer fake.findCustomerByVetOrgMutex.RUnlock()
	argsForCall := fake.findCustomerByVetOrgArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeCustomerService) FindCustomerByVetOrgReturns(result1 []model.Customer, result2 error) {
	fake.findCustomerByVetOrgMutex.Lock()
	defer fake.findCustomerByVetOrgMutex.Unlock()
	fake.FindCustomerByVetOrgStub = nil
	fake.findCustomerByVetOrgReturns = struct {
		result1 []model.Customer
		result2 error
	}{result1, result2}
}

func (fake *FakeCustomerService) FindCustomerByVetOrgReturnsOnCall(i int, result1 []model.Customer, result2 error) {
	fake.findCustomerByVetOrgMutex.Lock()
	defer fake.findCustomerByVetOrgMutex.Unlock()
	fake.FindCustomerByVetOrgStub = nil
	if fake.findCustomerByVetOrgReturnsOnCall == nil {
		fake.findCustomerByVetOrgReturnsOnCall = make(map[int]struct {
			result1 []model.Customer
			result2 error
		})
	}
	fake.findCustomerByVetOrgReturnsOnCall[i] = struct {
		result1 []model.Customer
		result2 error
	}{result1, result2}
}

func (fake *FakeCustomerService) Login(arg1 context.Context, arg2 string, arg3 string) (*model.Customer, error) {
	fake.loginMutex.Lock()
	ret, specificReturn := fake.loginReturnsOnCall[len(fake.loginArgsForCall)]
	fake.loginArgsForCall = append(fake.loginArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.LoginStub
	fakeReturns := fake.loginReturns
	fake.recordInvocation("Login", []interface{}{arg1, arg2, arg3})
	fake.loginMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeCustomerService) LoginCallCount() int {
	fake.loginMutex.RLock()
	defer fake.loginMutex.RUnlock()
	return len(fake.loginArgsForCall)
}

func (fake *FakeCustomerService) LoginCalls(stub func(context.Context, string, string) (*model.Customer, error)) {
	fake.loginMutex.Lock()
	defer fake.loginMutex.Unlock()
	fake.LoginStub = stub
}

func (fake *FakeCustomerService) LoginArgsForCall(i int) (context.Context, string, string) {
	fake.loginMutex.RLock()
	defer fake.loginMutex.RUnlock()
	argsForCall := fake.loginArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeCustomerService) LoginReturns(result1 *model.Customer, result2 error) {
	fake.loginMutex.Lock()
	defer fake.loginMutex.Unlock()
	fake.LoginStub = nil
	fake.loginReturns = struct {
		result1 *model.Customer
		result2 error
	}{result1, result2}
}

func (fake *FakeCustomerService) LoginReturnsOnCall(i int, result1 *model.Customer, result2 error) {
	fake.loginMutex.Lock()
	defer fake.loginMutex.Unlock()
	fake.LoginStub = nil
	if fake.loginReturnsOnCall == nil {
		fake.loginReturnsOnCall = make(map[int]struct {
			result1 *model.Customer
			result2 error
		})
	}
	fake.loginReturnsOnCall[i] = struct {
		result1 *model.Customer
		result2 error
	}{result1, result2}
}

func (fake *FakeCustomerService) UpdateCustomer(arg1 context.Context, arg2 model.Customer) (*model.Customer, error) {
	fake.updateCustomerMutex.Lock()
	ret, specificReturn := fake.updateCustomerReturnsOnCall[len(fake.updateCustomerArgsForCall)]
	fake.updateCustomerArgsForCall = append(fake.updateCustomerArgsForCall, struct {
		arg1 context.Context
		arg2 model.Customer
	}{arg1, arg2})
	stub := fake.UpdateCustomerStub
	fakeReturns := fake.updateCustomerReturns
	fake.recordInvocation("UpdateCustomer", []interface{}{arg1, arg2})
	fake.updateCustomerMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeCustomerService) UpdateCustomerCallCount() int {
	fake.updateCustomerMutex.RLock()
	defer fake.updateCustomerMutex.RUnlock()
	return len(fake.updateCustomerArgsForCall)
}

func (fake *FakeCustomerService) UpdateCustomerCalls(stub func(context.Context, model.Customer) (*model.Customer, error)) {
	fake.updateCustomerMutex.Lock()
	defer fake.updateCustomerMutex.Unlock()
	fake.UpdateCustomerStub = stub
}

func (fake *FakeCustomerService) UpdateCustomerArgsForCall(i int) (context.Context, model.Customer) {
	fake.updateCustomerMutex.RLock()
	defer fake.updateCustomerMutex.RUnlock()
	argsForCall := fake.updateCustomerArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeCustomerService) UpdateCustomerReturns(result1 *model.Customer, result2 error) {
	fake.updateCustomerMutex.Lock()
	defer fake.updateCustomerMutex.Unlock()
	fake.UpdateCustomerStub = nil
	fake.updateCustomerReturns = struct {
		result1 *model.Customer
		result2 error
	}{result1, result2}
}

func (fake *FakeCustomerService) UpdateCustomerReturnsOnCall(i int, result1 *model.Customer, result2 error) {
	fake.updateCustomerMutex.Lock()
	defer fake.updateCustomerMutex.Unlock()
	fake.UpdateCustomerStub = nil
	if fake.updateCustomerReturnsOnCall == nil {
		fake.updateCustomerReturnsOnCall = make(map[int]struct {
			result1 *model.Customer
			result2 error
		})
	}
	fake.updateCustomerReturnsOnCall[i] = struct {
		result1 *model.Customer
		result2 error
	}{result1, result2}
}

func (fake *FakeCustomerService) UpdatePassword(arg1 context.Context, arg2 model.Customer, arg3 string) (*model.Customer, error) {
	fake.updatePasswordMutex.Lock()
	ret, specificReturn := fake.updatePasswordReturnsOnCall[len(fake.updatePasswordArgsForCall)]
	fake.updatePasswordArgsForCall = append(fake.updatePasswordArgsForCall, struct {
		arg1 context.Context
		arg2 model.Customer
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.UpdatePasswordStub
	fakeReturns := fake.updatePasswordReturns
	fake.recordInvocation("UpdatePassword", []interface{}{arg1, arg2, arg3})
	fake.updatePasswordMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeCustomerService) UpdatePasswordCallCount() int {
	fake.updatePasswordMutex.RLock()
	defer fake.updatePasswordMutex.RUnlock()
	return len(fake.updatePasswordArgsForCall)
}

func (fake *FakeCustomerService) UpdatePasswordCalls(stub func(context.Context, model.Customer, string) (*model.Customer, error)) {
	fake.updatePasswordMutex.Lock()
	defer fake.updatePasswordMutex.Unlock()
	fake.UpdatePasswordStub = stub
}

func (fake *FakeCustomerService) UpdatePasswordArgsForCall(i int) (context.Context, model.Customer, string) {
	fake.updatePasswordMutex.RLock()
	defer fake.updatePasswordMutex.RUnlock()
	argsForCall := fake.updatePasswordArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeCustomerService) UpdatePasswordReturns(result1 *model.Customer, result2 error) {
	fake.updatePasswordMutex.Lock()
	defer fake.updatePasswordMutex.Unlock()
	fake.UpdatePasswordStub = nil
	fake.updatePasswordReturns = struct {
		result1 *model.Customer
		result2 error
	}{result1, result2}
}

func (fake *FakeCustomerService) UpdatePasswordReturnsOnCall(i int, result1 *model.Customer, result2 error) {
	fake.updatePasswordMutex.Lock()
	defer fake.updatePasswordMutex.Unlock()
	fake.UpdatePasswordStub = nil
	if fake.updatePasswordReturnsOnCall == nil {
		fake.updatePasswordReturnsOnCall = make(map[int]struct {
			result1 *model.Customer
			result2 error
		})
	}
	fake.updatePasswordReturnsOnCall[i] = struct {
		result1 *model.Customer
		result2 error
	}{result1, result2}
}

func (fake *FakeCustomerService) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.createCustomerMutex.RLock()
	defer fake.createCustomerMutex.RUnlock()
	fake.deleteCustomerMutex.RLock()
	defer fake.deleteCustomerMutex.RUnlock()
	fake.findCustomerByIDMutex.RLock()
	defer fake.findCustomerByIDMutex.RUnlock()
	fake.findCustomerByUserNameMutex.RLock()
	defer fake.findCustomerByUserNameMutex.RUnlock()
	fake.findCustomerByVetOrgMutex.RLock()
	defer fake.findCustomerByVetOrgMutex.RUnlock()
	fake.loginMutex.RLock()
	defer fake.loginMutex.RUnlock()
	fake.updateCustomerMutex.RLock()
	defer fake.updateCustomerMutex.RUnlock()
	fake.updatePasswordMutex.RLock()
	defer fake.updatePasswordMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeCustomerService) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ api.CustomerService = new(FakeCustomerService)
