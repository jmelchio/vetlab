// Code generated by counterfeiter. DO NOT EDIT.
package apifakes

import (
	"context"
	"sync"

	"github.com/jmelchio/vetlab/api"
	"github.com/jmelchio/vetlab/model"
)

type FakeVetOrgService struct {
	AddCustomerToVetOrgStub        func(context.Context, model.Customer, model.VetOrg) (*model.Customer, error)
	addCustomerToVetOrgMutex       sync.RWMutex
	addCustomerToVetOrgArgsForCall []struct {
		arg1 context.Context
		arg2 model.Customer
		arg3 model.VetOrg
	}
	addCustomerToVetOrgReturns struct {
		result1 *model.Customer
		result2 error
	}
	addCustomerToVetOrgReturnsOnCall map[int]struct {
		result1 *model.Customer
		result2 error
	}
	CreateVetOrgStub        func(context.Context, model.VetOrg) (*model.VetOrg, error)
	createVetOrgMutex       sync.RWMutex
	createVetOrgArgsForCall []struct {
		arg1 context.Context
		arg2 model.VetOrg
	}
	createVetOrgReturns struct {
		result1 *model.VetOrg
		result2 error
	}
	createVetOrgReturnsOnCall map[int]struct {
		result1 *model.VetOrg
		result2 error
	}
	DeleteVetOrgStub        func(context.Context, model.VetOrg) error
	deleteVetOrgMutex       sync.RWMutex
	deleteVetOrgArgsForCall []struct {
		arg1 context.Context
		arg2 model.VetOrg
	}
	deleteVetOrgReturns struct {
		result1 error
	}
	deleteVetOrgReturnsOnCall map[int]struct {
		result1 error
	}
	FindVetOrgByIDStub        func(context.Context, uint) (*model.VetOrg, error)
	findVetOrgByIDMutex       sync.RWMutex
	findVetOrgByIDArgsForCall []struct {
		arg1 context.Context
		arg2 uint
	}
	findVetOrgByIDReturns struct {
		result1 *model.VetOrg
		result2 error
	}
	findVetOrgByIDReturnsOnCall map[int]struct {
		result1 *model.VetOrg
		result2 error
	}
	FindVetOrgByNameStub        func(context.Context, string) ([]model.VetOrg, error)
	findVetOrgByNameMutex       sync.RWMutex
	findVetOrgByNameArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	findVetOrgByNameReturns struct {
		result1 []model.VetOrg
		result2 error
	}
	findVetOrgByNameReturnsOnCall map[int]struct {
		result1 []model.VetOrg
		result2 error
	}
	RemoveCustomerFromVetOrgStub        func(context.Context, model.Customer, model.VetOrg) (*model.Customer, error)
	removeCustomerFromVetOrgMutex       sync.RWMutex
	removeCustomerFromVetOrgArgsForCall []struct {
		arg1 context.Context
		arg2 model.Customer
		arg3 model.VetOrg
	}
	removeCustomerFromVetOrgReturns struct {
		result1 *model.Customer
		result2 error
	}
	removeCustomerFromVetOrgReturnsOnCall map[int]struct {
		result1 *model.Customer
		result2 error
	}
	UpdateVetOrgStub        func(context.Context, model.VetOrg) (*model.VetOrg, error)
	updateVetOrgMutex       sync.RWMutex
	updateVetOrgArgsForCall []struct {
		arg1 context.Context
		arg2 model.VetOrg
	}
	updateVetOrgReturns struct {
		result1 *model.VetOrg
		result2 error
	}
	updateVetOrgReturnsOnCall map[int]struct {
		result1 *model.VetOrg
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeVetOrgService) AddCustomerToVetOrg(arg1 context.Context, arg2 model.Customer, arg3 model.VetOrg) (*model.Customer, error) {
	fake.addCustomerToVetOrgMutex.Lock()
	ret, specificReturn := fake.addCustomerToVetOrgReturnsOnCall[len(fake.addCustomerToVetOrgArgsForCall)]
	fake.addCustomerToVetOrgArgsForCall = append(fake.addCustomerToVetOrgArgsForCall, struct {
		arg1 context.Context
		arg2 model.Customer
		arg3 model.VetOrg
	}{arg1, arg2, arg3})
	stub := fake.AddCustomerToVetOrgStub
	fakeReturns := fake.addCustomerToVetOrgReturns
	fake.recordInvocation("AddCustomerToVetOrg", []interface{}{arg1, arg2, arg3})
	fake.addCustomerToVetOrgMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeVetOrgService) AddCustomerToVetOrgCallCount() int {
	fake.addCustomerToVetOrgMutex.RLock()
	defer fake.addCustomerToVetOrgMutex.RUnlock()
	return len(fake.addCustomerToVetOrgArgsForCall)
}

func (fake *FakeVetOrgService) AddCustomerToVetOrgCalls(stub func(context.Context, model.Customer, model.VetOrg) (*model.Customer, error)) {
	fake.addCustomerToVetOrgMutex.Lock()
	defer fake.addCustomerToVetOrgMutex.Unlock()
	fake.AddCustomerToVetOrgStub = stub
}

func (fake *FakeVetOrgService) AddCustomerToVetOrgArgsForCall(i int) (context.Context, model.Customer, model.VetOrg) {
	fake.addCustomerToVetOrgMutex.RLock()
	defer fake.addCustomerToVetOrgMutex.RUnlock()
	argsForCall := fake.addCustomerToVetOrgArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeVetOrgService) AddCustomerToVetOrgReturns(result1 *model.Customer, result2 error) {
	fake.addCustomerToVetOrgMutex.Lock()
	defer fake.addCustomerToVetOrgMutex.Unlock()
	fake.AddCustomerToVetOrgStub = nil
	fake.addCustomerToVetOrgReturns = struct {
		result1 *model.Customer
		result2 error
	}{result1, result2}
}

func (fake *FakeVetOrgService) AddCustomerToVetOrgReturnsOnCall(i int, result1 *model.Customer, result2 error) {
	fake.addCustomerToVetOrgMutex.Lock()
	defer fake.addCustomerToVetOrgMutex.Unlock()
	fake.AddCustomerToVetOrgStub = nil
	if fake.addCustomerToVetOrgReturnsOnCall == nil {
		fake.addCustomerToVetOrgReturnsOnCall = make(map[int]struct {
			result1 *model.Customer
			result2 error
		})
	}
	fake.addCustomerToVetOrgReturnsOnCall[i] = struct {
		result1 *model.Customer
		result2 error
	}{result1, result2}
}

func (fake *FakeVetOrgService) CreateVetOrg(arg1 context.Context, arg2 model.VetOrg) (*model.VetOrg, error) {
	fake.createVetOrgMutex.Lock()
	ret, specificReturn := fake.createVetOrgReturnsOnCall[len(fake.createVetOrgArgsForCall)]
	fake.createVetOrgArgsForCall = append(fake.createVetOrgArgsForCall, struct {
		arg1 context.Context
		arg2 model.VetOrg
	}{arg1, arg2})
	stub := fake.CreateVetOrgStub
	fakeReturns := fake.createVetOrgReturns
	fake.recordInvocation("CreateVetOrg", []interface{}{arg1, arg2})
	fake.createVetOrgMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeVetOrgService) CreateVetOrgCallCount() int {
	fake.createVetOrgMutex.RLock()
	defer fake.createVetOrgMutex.RUnlock()
	return len(fake.createVetOrgArgsForCall)
}

func (fake *FakeVetOrgService) CreateVetOrgCalls(stub func(context.Context, model.VetOrg) (*model.VetOrg, error)) {
	fake.createVetOrgMutex.Lock()
	defer fake.createVetOrgMutex.Unlock()
	fake.CreateVetOrgStub = stub
}

func (fake *FakeVetOrgService) CreateVetOrgArgsForCall(i int) (context.Context, model.VetOrg) {
	fake.createVetOrgMutex.RLock()
	defer fake.createVetOrgMutex.RUnlock()
	argsForCall := fake.createVetOrgArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeVetOrgService) CreateVetOrgReturns(result1 *model.VetOrg, result2 error) {
	fake.createVetOrgMutex.Lock()
	defer fake.createVetOrgMutex.Unlock()
	fake.CreateVetOrgStub = nil
	fake.createVetOrgReturns = struct {
		result1 *model.VetOrg
		result2 error
	}{result1, result2}
}

func (fake *FakeVetOrgService) CreateVetOrgReturnsOnCall(i int, result1 *model.VetOrg, result2 error) {
	fake.createVetOrgMutex.Lock()
	defer fake.createVetOrgMutex.Unlock()
	fake.CreateVetOrgStub = nil
	if fake.createVetOrgReturnsOnCall == nil {
		fake.createVetOrgReturnsOnCall = make(map[int]struct {
			result1 *model.VetOrg
			result2 error
		})
	}
	fake.createVetOrgReturnsOnCall[i] = struct {
		result1 *model.VetOrg
		result2 error
	}{result1, result2}
}

func (fake *FakeVetOrgService) DeleteVetOrg(arg1 context.Context, arg2 model.VetOrg) error {
	fake.deleteVetOrgMutex.Lock()
	ret, specificReturn := fake.deleteVetOrgReturnsOnCall[len(fake.deleteVetOrgArgsForCall)]
	fake.deleteVetOrgArgsForCall = append(fake.deleteVetOrgArgsForCall, struct {
		arg1 context.Context
		arg2 model.VetOrg
	}{arg1, arg2})
	stub := fake.DeleteVetOrgStub
	fakeReturns := fake.deleteVetOrgReturns
	fake.recordInvocation("DeleteVetOrg", []interface{}{arg1, arg2})
	fake.deleteVetOrgMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeVetOrgService) DeleteVetOrgCallCount() int {
	fake.deleteVetOrgMutex.RLock()
	defer fake.deleteVetOrgMutex.RUnlock()
	return len(fake.deleteVetOrgArgsForCall)
}

func (fake *FakeVetOrgService) DeleteVetOrgCalls(stub func(context.Context, model.VetOrg) error) {
	fake.deleteVetOrgMutex.Lock()
	defer fake.deleteVetOrgMutex.Unlock()
	fake.DeleteVetOrgStub = stub
}

func (fake *FakeVetOrgService) DeleteVetOrgArgsForCall(i int) (context.Context, model.VetOrg) {
	fake.deleteVetOrgMutex.RLock()
	defer fake.deleteVetOrgMutex.RUnlock()
	argsForCall := fake.deleteVetOrgArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeVetOrgService) DeleteVetOrgReturns(result1 error) {
	fake.deleteVetOrgMutex.Lock()
	defer fake.deleteVetOrgMutex.Unlock()
	fake.DeleteVetOrgStub = nil
	fake.deleteVetOrgReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeVetOrgService) DeleteVetOrgReturnsOnCall(i int, result1 error) {
	fake.deleteVetOrgMutex.Lock()
	defer fake.deleteVetOrgMutex.Unlock()
	fake.DeleteVetOrgStub = nil
	if fake.deleteVetOrgReturnsOnCall == nil {
		fake.deleteVetOrgReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteVetOrgReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeVetOrgService) FindVetOrgByID(arg1 context.Context, arg2 uint) (*model.VetOrg, error) {
	fake.findVetOrgByIDMutex.Lock()
	ret, specificReturn := fake.findVetOrgByIDReturnsOnCall[len(fake.findVetOrgByIDArgsForCall)]
	fake.findVetOrgByIDArgsForCall = append(fake.findVetOrgByIDArgsForCall, struct {
		arg1 context.Context
		arg2 uint
	}{arg1, arg2})
	stub := fake.FindVetOrgByIDStub
	fakeReturns := fake.findVetOrgByIDReturns
	fake.recordInvocation("FindVetOrgByID", []interface{}{arg1, arg2})
	fake.findVetOrgByIDMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeVetOrgService) FindVetOrgByIDCallCount() int {
	fake.findVetOrgByIDMutex.RLock()
	defer fake.findVetOrgByIDMutex.RUnlock()
	return len(fake.findVetOrgByIDArgsForCall)
}

func (fake *FakeVetOrgService) FindVetOrgByIDCalls(stub func(context.Context, uint) (*model.VetOrg, error)) {
	fake.findVetOrgByIDMutex.Lock()
	defer fake.findVetOrgByIDMutex.Unlock()
	fake.FindVetOrgByIDStub = stub
}

func (fake *FakeVetOrgService) FindVetOrgByIDArgsForCall(i int) (context.Context, uint) {
	fake.findVetOrgByIDMutex.RLock()
	defer fake.findVetOrgByIDMutex.RUnlock()
	argsForCall := fake.findVetOrgByIDArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeVetOrgService) FindVetOrgByIDReturns(result1 *model.VetOrg, result2 error) {
	fake.findVetOrgByIDMutex.Lock()
	defer fake.findVetOrgByIDMutex.Unlock()
	fake.FindVetOrgByIDStub = nil
	fake.findVetOrgByIDReturns = struct {
		result1 *model.VetOrg
		result2 error
	}{result1, result2}
}

func (fake *FakeVetOrgService) FindVetOrgByIDReturnsOnCall(i int, result1 *model.VetOrg, result2 error) {
	fake.findVetOrgByIDMutex.Lock()
	defer fake.findVetOrgByIDMutex.Unlock()
	fake.FindVetOrgByIDStub = nil
	if fake.findVetOrgByIDReturnsOnCall == nil {
		fake.findVetOrgByIDReturnsOnCall = make(map[int]struct {
			result1 *model.VetOrg
			result2 error
		})
	}
	fake.findVetOrgByIDReturnsOnCall[i] = struct {
		result1 *model.VetOrg
		result2 error
	}{result1, result2}
}

func (fake *FakeVetOrgService) FindVetOrgByName(arg1 context.Context, arg2 string) ([]model.VetOrg, error) {
	fake.findVetOrgByNameMutex.Lock()
	ret, specificReturn := fake.findVetOrgByNameReturnsOnCall[len(fake.findVetOrgByNameArgsForCall)]
	fake.findVetOrgByNameArgsForCall = append(fake.findVetOrgByNameArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.FindVetOrgByNameStub
	fakeReturns := fake.findVetOrgByNameReturns
	fake.recordInvocation("FindVetOrgByName", []interface{}{arg1, arg2})
	fake.findVetOrgByNameMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeVetOrgService) FindVetOrgByNameCallCount() int {
	fake.findVetOrgByNameMutex.RLock()
	defer fake.findVetOrgByNameMutex.RUnlock()
	return len(fake.findVetOrgByNameArgsForCall)
}

func (fake *FakeVetOrgService) FindVetOrgByNameCalls(stub func(context.Context, string) ([]model.VetOrg, error)) {
	fake.findVetOrgByNameMutex.Lock()
	defer fake.findVetOrgByNameMutex.Unlock()
	fake.FindVetOrgByNameStub = stub
}

func (fake *FakeVetOrgService) FindVetOrgByNameArgsForCall(i int) (context.Context, string) {
	fake.findVetOrgByNameMutex.RLock()
	defer fake.findVetOrgByNameMutex.RUnlock()
	argsForCall := fake.findVetOrgByNameArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeVetOrgService) FindVetOrgByNameReturns(result1 []model.VetOrg, result2 error) {
	fake.findVetOrgByNameMutex.Lock()
	defer fake.findVetOrgByNameMutex.Unlock()
	fake.FindVetOrgByNameStub = nil
	fake.findVetOrgByNameReturns = struct {
		result1 []model.VetOrg
		result2 error
	}{result1, result2}
}

func (fake *FakeVetOrgService) FindVetOrgByNameReturnsOnCall(i int, result1 []model.VetOrg, result2 error) {
	fake.findVetOrgByNameMutex.Lock()
	defer fake.findVetOrgByNameMutex.Unlock()
	fake.FindVetOrgByNameStub = nil
	if fake.findVetOrgByNameReturnsOnCall == nil {
		fake.findVetOrgByNameReturnsOnCall = make(map[int]struct {
			result1 []model.VetOrg
			result2 error
		})
	}
	fake.findVetOrgByNameReturnsOnCall[i] = struct {
		result1 []model.VetOrg
		result2 error
	}{result1, result2}
}

func (fake *FakeVetOrgService) RemoveCustomerFromVetOrg(arg1 context.Context, arg2 model.Customer, arg3 model.VetOrg) (*model.Customer, error) {
	fake.removeCustomerFromVetOrgMutex.Lock()
	ret, specificReturn := fake.removeCustomerFromVetOrgReturnsOnCall[len(fake.removeCustomerFromVetOrgArgsForCall)]
	fake.removeCustomerFromVetOrgArgsForCall = append(fake.removeCustomerFromVetOrgArgsForCall, struct {
		arg1 context.Context
		arg2 model.Customer
		arg3 model.VetOrg
	}{arg1, arg2, arg3})
	stub := fake.RemoveCustomerFromVetOrgStub
	fakeReturns := fake.removeCustomerFromVetOrgReturns
	fake.recordInvocation("RemoveCustomerFromVetOrg", []interface{}{arg1, arg2, arg3})
	fake.removeCustomerFromVetOrgMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeVetOrgService) RemoveCustomerFromVetOrgCallCount() int {
	fake.removeCustomerFromVetOrgMutex.RLock()
	defer fake.removeCustomerFromVetOrgMutex.RUnlock()
	return len(fake.removeCustomerFromVetOrgArgsForCall)
}

func (fake *FakeVetOrgService) RemoveCustomerFromVetOrgCalls(stub func(context.Context, model.Customer, model.VetOrg) (*model.Customer, error)) {
	fake.removeCustomerFromVetOrgMutex.Lock()
	defer fake.removeCustomerFromVetOrgMutex.Unlock()
	fake.RemoveCustomerFromVetOrgStub = stub
}

func (fake *FakeVetOrgService) RemoveCustomerFromVetOrgArgsForCall(i int) (context.Context, model.Customer, model.VetOrg) {
	fake.removeCustomerFromVetOrgMutex.RLock()
	defer fake.removeCustomerFromVetOrgMutex.RUnlock()
	argsForCall := fake.removeCustomerFromVetOrgArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeVetOrgService) RemoveCustomerFromVetOrgReturns(result1 *model.Customer, result2 error) {
	fake.removeCustomerFromVetOrgMutex.Lock()
	defer fake.removeCustomerFromVetOrgMutex.Unlock()
	fake.RemoveCustomerFromVetOrgStub = nil
	fake.removeCustomerFromVetOrgReturns = struct {
		result1 *model.Customer
		result2 error
	}{result1, result2}
}

func (fake *FakeVetOrgService) RemoveCustomerFromVetOrgReturnsOnCall(i int, result1 *model.Customer, result2 error) {
	fake.removeCustomerFromVetOrgMutex.Lock()
	defer fake.removeCustomerFromVetOrgMutex.Unlock()
	fake.RemoveCustomerFromVetOrgStub = nil
	if fake.removeCustomerFromVetOrgReturnsOnCall == nil {
		fake.removeCustomerFromVetOrgReturnsOnCall = make(map[int]struct {
			result1 *model.Customer
			result2 error
		})
	}
	fake.removeCustomerFromVetOrgReturnsOnCall[i] = struct {
		result1 *model.Customer
		result2 error
	}{result1, result2}
}

func (fake *FakeVetOrgService) UpdateVetOrg(arg1 context.Context, arg2 model.VetOrg) (*model.VetOrg, error) {
	fake.updateVetOrgMutex.Lock()
	ret, specificReturn := fake.updateVetOrgReturnsOnCall[len(fake.updateVetOrgArgsForCall)]
	fake.updateVetOrgArgsForCall = append(fake.updateVetOrgArgsForCall, struct {
		arg1 context.Context
		arg2 model.VetOrg
	}{arg1, arg2})
	stub := fake.UpdateVetOrgStub
	fakeReturns := fake.updateVetOrgReturns
	fake.recordInvocation("UpdateVetOrg", []interface{}{arg1, arg2})
	fake.updateVetOrgMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeVetOrgService) UpdateVetOrgCallCount() int {
	fake.updateVetOrgMutex.RLock()
	defer fake.updateVetOrgMutex.RUnlock()
	return len(fake.updateVetOrgArgsForCall)
}

func (fake *FakeVetOrgService) UpdateVetOrgCalls(stub func(context.Context, model.VetOrg) (*model.VetOrg, error)) {
	fake.updateVetOrgMutex.Lock()
	defer fake.updateVetOrgMutex.Unlock()
	fake.UpdateVetOrgStub = stub
}

func (fake *FakeVetOrgService) UpdateVetOrgArgsForCall(i int) (context.Context, model.VetOrg) {
	fake.updateVetOrgMutex.RLock()
	defer fake.updateVetOrgMutex.RUnlock()
	argsForCall := fake.updateVetOrgArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeVetOrgService) UpdateVetOrgReturns(result1 *model.VetOrg, result2 error) {
	fake.updateVetOrgMutex.Lock()
	defer fake.updateVetOrgMutex.Unlock()
	fake.UpdateVetOrgStub = nil
	fake.updateVetOrgReturns = struct {
		result1 *model.VetOrg
		result2 error
	}{result1, result2}
}

func (fake *FakeVetOrgService) UpdateVetOrgReturnsOnCall(i int, result1 *model.VetOrg, result2 error) {
	fake.updateVetOrgMutex.Lock()
	defer fake.updateVetOrgMutex.Unlock()
	fake.UpdateVetOrgStub = nil
	if fake.updateVetOrgReturnsOnCall == nil {
		fake.updateVetOrgReturnsOnCall = make(map[int]struct {
			result1 *model.VetOrg
			result2 error
		})
	}
	fake.updateVetOrgReturnsOnCall[i] = struct {
		result1 *model.VetOrg
		result2 error
	}{result1, result2}
}

func (fake *FakeVetOrgService) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.addCustomerToVetOrgMutex.RLock()
	defer fake.addCustomerToVetOrgMutex.RUnlock()
	fake.createVetOrgMutex.RLock()
	defer fake.createVetOrgMutex.RUnlock()
	fake.deleteVetOrgMutex.RLock()
	defer fake.deleteVetOrgMutex.RUnlock()
	fake.findVetOrgByIDMutex.RLock()
	defer fake.findVetOrgByIDMutex.RUnlock()
	fake.findVetOrgByNameMutex.RLock()
	defer fake.findVetOrgByNameMutex.RUnlock()
	fake.removeCustomerFromVetOrgMutex.RLock()
	defer fake.removeCustomerFromVetOrgMutex.RUnlock()
	fake.updateVetOrgMutex.RLock()
	defer fake.updateVetOrgMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeVetOrgService) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ api.VetOrgService = new(FakeVetOrgService)
