// Code generated by counterfeiter. DO NOT EDIT.
package apifakes

import (
	"context"
	"sync"

	"github.com/jmelchio/vetlab/api"
	"github.com/jmelchio/vetlab/model"
)

type FakeVetOrgService struct {
	AddUserToVetOrgStub        func(context.Context, model.User, model.VetOrg) (*model.User, error)
	addUserToVetOrgMutex       sync.RWMutex
	addUserToVetOrgArgsForCall []struct {
		arg1 context.Context
		arg2 model.User
		arg3 model.VetOrg
	}
	addUserToVetOrgReturns struct {
		result1 *model.User
		result2 error
	}
	addUserToVetOrgReturnsOnCall map[int]struct {
		result1 *model.User
		result2 error
	}
	CreateVetOrgStub        func(context.Context, model.VetOrg) (*model.VetOrg, error)
	createVetOrgMutex       sync.RWMutex
	createVetOrgArgsForCall []struct {
		arg1 context.Context
		arg2 model.VetOrg
	}
	createVetOrgReturns struct {
		result1 *model.VetOrg
		result2 error
	}
	createVetOrgReturnsOnCall map[int]struct {
		result1 *model.VetOrg
		result2 error
	}
	DeleteVetOrgStub        func(context.Context, model.VetOrg) error
	deleteVetOrgMutex       sync.RWMutex
	deleteVetOrgArgsForCall []struct {
		arg1 context.Context
		arg2 model.VetOrg
	}
	deleteVetOrgReturns struct {
		result1 error
	}
	deleteVetOrgReturnsOnCall map[int]struct {
		result1 error
	}
	FindVetOrgByIDStub        func(context.Context, uint) (*model.VetOrg, error)
	findVetOrgByIDMutex       sync.RWMutex
	findVetOrgByIDArgsForCall []struct {
		arg1 context.Context
		arg2 uint
	}
	findVetOrgByIDReturns struct {
		result1 *model.VetOrg
		result2 error
	}
	findVetOrgByIDReturnsOnCall map[int]struct {
		result1 *model.VetOrg
		result2 error
	}
	FindVetOrgByNameStub        func(context.Context, string) ([]model.VetOrg, error)
	findVetOrgByNameMutex       sync.RWMutex
	findVetOrgByNameArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	findVetOrgByNameReturns struct {
		result1 []model.VetOrg
		result2 error
	}
	findVetOrgByNameReturnsOnCall map[int]struct {
		result1 []model.VetOrg
		result2 error
	}
	UpdateVetOrgStub        func(context.Context, model.VetOrg) (*model.VetOrg, error)
	updateVetOrgMutex       sync.RWMutex
	updateVetOrgArgsForCall []struct {
		arg1 context.Context
		arg2 model.VetOrg
	}
	updateVetOrgReturns struct {
		result1 *model.VetOrg
		result2 error
	}
	updateVetOrgReturnsOnCall map[int]struct {
		result1 *model.VetOrg
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeVetOrgService) AddUserToVetOrg(arg1 context.Context, arg2 model.User, arg3 model.VetOrg) (*model.User, error) {
	fake.addUserToVetOrgMutex.Lock()
	ret, specificReturn := fake.addUserToVetOrgReturnsOnCall[len(fake.addUserToVetOrgArgsForCall)]
	fake.addUserToVetOrgArgsForCall = append(fake.addUserToVetOrgArgsForCall, struct {
		arg1 context.Context
		arg2 model.User
		arg3 model.VetOrg
	}{arg1, arg2, arg3})
	fake.recordInvocation("AddUserToVetOrg", []interface{}{arg1, arg2, arg3})
	fake.addUserToVetOrgMutex.Unlock()
	if fake.AddUserToVetOrgStub != nil {
		return fake.AddUserToVetOrgStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.addUserToVetOrgReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeVetOrgService) AddUserToVetOrgCallCount() int {
	fake.addUserToVetOrgMutex.RLock()
	defer fake.addUserToVetOrgMutex.RUnlock()
	return len(fake.addUserToVetOrgArgsForCall)
}

func (fake *FakeVetOrgService) AddUserToVetOrgCalls(stub func(context.Context, model.User, model.VetOrg) (*model.User, error)) {
	fake.addUserToVetOrgMutex.Lock()
	defer fake.addUserToVetOrgMutex.Unlock()
	fake.AddUserToVetOrgStub = stub
}

func (fake *FakeVetOrgService) AddUserToVetOrgArgsForCall(i int) (context.Context, model.User, model.VetOrg) {
	fake.addUserToVetOrgMutex.RLock()
	defer fake.addUserToVetOrgMutex.RUnlock()
	argsForCall := fake.addUserToVetOrgArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeVetOrgService) AddUserToVetOrgReturns(result1 *model.User, result2 error) {
	fake.addUserToVetOrgMutex.Lock()
	defer fake.addUserToVetOrgMutex.Unlock()
	fake.AddUserToVetOrgStub = nil
	fake.addUserToVetOrgReturns = struct {
		result1 *model.User
		result2 error
	}{result1, result2}
}

func (fake *FakeVetOrgService) AddUserToVetOrgReturnsOnCall(i int, result1 *model.User, result2 error) {
	fake.addUserToVetOrgMutex.Lock()
	defer fake.addUserToVetOrgMutex.Unlock()
	fake.AddUserToVetOrgStub = nil
	if fake.addUserToVetOrgReturnsOnCall == nil {
		fake.addUserToVetOrgReturnsOnCall = make(map[int]struct {
			result1 *model.User
			result2 error
		})
	}
	fake.addUserToVetOrgReturnsOnCall[i] = struct {
		result1 *model.User
		result2 error
	}{result1, result2}
}

func (fake *FakeVetOrgService) CreateVetOrg(arg1 context.Context, arg2 model.VetOrg) (*model.VetOrg, error) {
	fake.createVetOrgMutex.Lock()
	ret, specificReturn := fake.createVetOrgReturnsOnCall[len(fake.createVetOrgArgsForCall)]
	fake.createVetOrgArgsForCall = append(fake.createVetOrgArgsForCall, struct {
		arg1 context.Context
		arg2 model.VetOrg
	}{arg1, arg2})
	fake.recordInvocation("CreateVetOrg", []interface{}{arg1, arg2})
	fake.createVetOrgMutex.Unlock()
	if fake.CreateVetOrgStub != nil {
		return fake.CreateVetOrgStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.createVetOrgReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeVetOrgService) CreateVetOrgCallCount() int {
	fake.createVetOrgMutex.RLock()
	defer fake.createVetOrgMutex.RUnlock()
	return len(fake.createVetOrgArgsForCall)
}

func (fake *FakeVetOrgService) CreateVetOrgCalls(stub func(context.Context, model.VetOrg) (*model.VetOrg, error)) {
	fake.createVetOrgMutex.Lock()
	defer fake.createVetOrgMutex.Unlock()
	fake.CreateVetOrgStub = stub
}

func (fake *FakeVetOrgService) CreateVetOrgArgsForCall(i int) (context.Context, model.VetOrg) {
	fake.createVetOrgMutex.RLock()
	defer fake.createVetOrgMutex.RUnlock()
	argsForCall := fake.createVetOrgArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeVetOrgService) CreateVetOrgReturns(result1 *model.VetOrg, result2 error) {
	fake.createVetOrgMutex.Lock()
	defer fake.createVetOrgMutex.Unlock()
	fake.CreateVetOrgStub = nil
	fake.createVetOrgReturns = struct {
		result1 *model.VetOrg
		result2 error
	}{result1, result2}
}

func (fake *FakeVetOrgService) CreateVetOrgReturnsOnCall(i int, result1 *model.VetOrg, result2 error) {
	fake.createVetOrgMutex.Lock()
	defer fake.createVetOrgMutex.Unlock()
	fake.CreateVetOrgStub = nil
	if fake.createVetOrgReturnsOnCall == nil {
		fake.createVetOrgReturnsOnCall = make(map[int]struct {
			result1 *model.VetOrg
			result2 error
		})
	}
	fake.createVetOrgReturnsOnCall[i] = struct {
		result1 *model.VetOrg
		result2 error
	}{result1, result2}
}

func (fake *FakeVetOrgService) DeleteVetOrg(arg1 context.Context, arg2 model.VetOrg) error {
	fake.deleteVetOrgMutex.Lock()
	ret, specificReturn := fake.deleteVetOrgReturnsOnCall[len(fake.deleteVetOrgArgsForCall)]
	fake.deleteVetOrgArgsForCall = append(fake.deleteVetOrgArgsForCall, struct {
		arg1 context.Context
		arg2 model.VetOrg
	}{arg1, arg2})
	fake.recordInvocation("DeleteVetOrg", []interface{}{arg1, arg2})
	fake.deleteVetOrgMutex.Unlock()
	if fake.DeleteVetOrgStub != nil {
		return fake.DeleteVetOrgStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.deleteVetOrgReturns
	return fakeReturns.result1
}

func (fake *FakeVetOrgService) DeleteVetOrgCallCount() int {
	fake.deleteVetOrgMutex.RLock()
	defer fake.deleteVetOrgMutex.RUnlock()
	return len(fake.deleteVetOrgArgsForCall)
}

func (fake *FakeVetOrgService) DeleteVetOrgCalls(stub func(context.Context, model.VetOrg) error) {
	fake.deleteVetOrgMutex.Lock()
	defer fake.deleteVetOrgMutex.Unlock()
	fake.DeleteVetOrgStub = stub
}

func (fake *FakeVetOrgService) DeleteVetOrgArgsForCall(i int) (context.Context, model.VetOrg) {
	fake.deleteVetOrgMutex.RLock()
	defer fake.deleteVetOrgMutex.RUnlock()
	argsForCall := fake.deleteVetOrgArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeVetOrgService) DeleteVetOrgReturns(result1 error) {
	fake.deleteVetOrgMutex.Lock()
	defer fake.deleteVetOrgMutex.Unlock()
	fake.DeleteVetOrgStub = nil
	fake.deleteVetOrgReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeVetOrgService) DeleteVetOrgReturnsOnCall(i int, result1 error) {
	fake.deleteVetOrgMutex.Lock()
	defer fake.deleteVetOrgMutex.Unlock()
	fake.DeleteVetOrgStub = nil
	if fake.deleteVetOrgReturnsOnCall == nil {
		fake.deleteVetOrgReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteVetOrgReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeVetOrgService) FindVetOrgByID(arg1 context.Context, arg2 uint) (*model.VetOrg, error) {
	fake.findVetOrgByIDMutex.Lock()
	ret, specificReturn := fake.findVetOrgByIDReturnsOnCall[len(fake.findVetOrgByIDArgsForCall)]
	fake.findVetOrgByIDArgsForCall = append(fake.findVetOrgByIDArgsForCall, struct {
		arg1 context.Context
		arg2 uint
	}{arg1, arg2})
	fake.recordInvocation("FindVetOrgByID", []interface{}{arg1, arg2})
	fake.findVetOrgByIDMutex.Unlock()
	if fake.FindVetOrgByIDStub != nil {
		return fake.FindVetOrgByIDStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.findVetOrgByIDReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeVetOrgService) FindVetOrgByIDCallCount() int {
	fake.findVetOrgByIDMutex.RLock()
	defer fake.findVetOrgByIDMutex.RUnlock()
	return len(fake.findVetOrgByIDArgsForCall)
}

func (fake *FakeVetOrgService) FindVetOrgByIDCalls(stub func(context.Context, uint) (*model.VetOrg, error)) {
	fake.findVetOrgByIDMutex.Lock()
	defer fake.findVetOrgByIDMutex.Unlock()
	fake.FindVetOrgByIDStub = stub
}

func (fake *FakeVetOrgService) FindVetOrgByIDArgsForCall(i int) (context.Context, uint) {
	fake.findVetOrgByIDMutex.RLock()
	defer fake.findVetOrgByIDMutex.RUnlock()
	argsForCall := fake.findVetOrgByIDArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeVetOrgService) FindVetOrgByIDReturns(result1 *model.VetOrg, result2 error) {
	fake.findVetOrgByIDMutex.Lock()
	defer fake.findVetOrgByIDMutex.Unlock()
	fake.FindVetOrgByIDStub = nil
	fake.findVetOrgByIDReturns = struct {
		result1 *model.VetOrg
		result2 error
	}{result1, result2}
}

func (fake *FakeVetOrgService) FindVetOrgByIDReturnsOnCall(i int, result1 *model.VetOrg, result2 error) {
	fake.findVetOrgByIDMutex.Lock()
	defer fake.findVetOrgByIDMutex.Unlock()
	fake.FindVetOrgByIDStub = nil
	if fake.findVetOrgByIDReturnsOnCall == nil {
		fake.findVetOrgByIDReturnsOnCall = make(map[int]struct {
			result1 *model.VetOrg
			result2 error
		})
	}
	fake.findVetOrgByIDReturnsOnCall[i] = struct {
		result1 *model.VetOrg
		result2 error
	}{result1, result2}
}

func (fake *FakeVetOrgService) FindVetOrgByName(arg1 context.Context, arg2 string) ([]model.VetOrg, error) {
	fake.findVetOrgByNameMutex.Lock()
	ret, specificReturn := fake.findVetOrgByNameReturnsOnCall[len(fake.findVetOrgByNameArgsForCall)]
	fake.findVetOrgByNameArgsForCall = append(fake.findVetOrgByNameArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("FindVetOrgByName", []interface{}{arg1, arg2})
	fake.findVetOrgByNameMutex.Unlock()
	if fake.FindVetOrgByNameStub != nil {
		return fake.FindVetOrgByNameStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.findVetOrgByNameReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeVetOrgService) FindVetOrgByNameCallCount() int {
	fake.findVetOrgByNameMutex.RLock()
	defer fake.findVetOrgByNameMutex.RUnlock()
	return len(fake.findVetOrgByNameArgsForCall)
}

func (fake *FakeVetOrgService) FindVetOrgByNameCalls(stub func(context.Context, string) ([]model.VetOrg, error)) {
	fake.findVetOrgByNameMutex.Lock()
	defer fake.findVetOrgByNameMutex.Unlock()
	fake.FindVetOrgByNameStub = stub
}

func (fake *FakeVetOrgService) FindVetOrgByNameArgsForCall(i int) (context.Context, string) {
	fake.findVetOrgByNameMutex.RLock()
	defer fake.findVetOrgByNameMutex.RUnlock()
	argsForCall := fake.findVetOrgByNameArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeVetOrgService) FindVetOrgByNameReturns(result1 []model.VetOrg, result2 error) {
	fake.findVetOrgByNameMutex.Lock()
	defer fake.findVetOrgByNameMutex.Unlock()
	fake.FindVetOrgByNameStub = nil
	fake.findVetOrgByNameReturns = struct {
		result1 []model.VetOrg
		result2 error
	}{result1, result2}
}

func (fake *FakeVetOrgService) FindVetOrgByNameReturnsOnCall(i int, result1 []model.VetOrg, result2 error) {
	fake.findVetOrgByNameMutex.Lock()
	defer fake.findVetOrgByNameMutex.Unlock()
	fake.FindVetOrgByNameStub = nil
	if fake.findVetOrgByNameReturnsOnCall == nil {
		fake.findVetOrgByNameReturnsOnCall = make(map[int]struct {
			result1 []model.VetOrg
			result2 error
		})
	}
	fake.findVetOrgByNameReturnsOnCall[i] = struct {
		result1 []model.VetOrg
		result2 error
	}{result1, result2}
}

func (fake *FakeVetOrgService) UpdateVetOrg(arg1 context.Context, arg2 model.VetOrg) (*model.VetOrg, error) {
	fake.updateVetOrgMutex.Lock()
	ret, specificReturn := fake.updateVetOrgReturnsOnCall[len(fake.updateVetOrgArgsForCall)]
	fake.updateVetOrgArgsForCall = append(fake.updateVetOrgArgsForCall, struct {
		arg1 context.Context
		arg2 model.VetOrg
	}{arg1, arg2})
	fake.recordInvocation("UpdateVetOrg", []interface{}{arg1, arg2})
	fake.updateVetOrgMutex.Unlock()
	if fake.UpdateVetOrgStub != nil {
		return fake.UpdateVetOrgStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.updateVetOrgReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeVetOrgService) UpdateVetOrgCallCount() int {
	fake.updateVetOrgMutex.RLock()
	defer fake.updateVetOrgMutex.RUnlock()
	return len(fake.updateVetOrgArgsForCall)
}

func (fake *FakeVetOrgService) UpdateVetOrgCalls(stub func(context.Context, model.VetOrg) (*model.VetOrg, error)) {
	fake.updateVetOrgMutex.Lock()
	defer fake.updateVetOrgMutex.Unlock()
	fake.UpdateVetOrgStub = stub
}

func (fake *FakeVetOrgService) UpdateVetOrgArgsForCall(i int) (context.Context, model.VetOrg) {
	fake.updateVetOrgMutex.RLock()
	defer fake.updateVetOrgMutex.RUnlock()
	argsForCall := fake.updateVetOrgArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeVetOrgService) UpdateVetOrgReturns(result1 *model.VetOrg, result2 error) {
	fake.updateVetOrgMutex.Lock()
	defer fake.updateVetOrgMutex.Unlock()
	fake.UpdateVetOrgStub = nil
	fake.updateVetOrgReturns = struct {
		result1 *model.VetOrg
		result2 error
	}{result1, result2}
}

func (fake *FakeVetOrgService) UpdateVetOrgReturnsOnCall(i int, result1 *model.VetOrg, result2 error) {
	fake.updateVetOrgMutex.Lock()
	defer fake.updateVetOrgMutex.Unlock()
	fake.UpdateVetOrgStub = nil
	if fake.updateVetOrgReturnsOnCall == nil {
		fake.updateVetOrgReturnsOnCall = make(map[int]struct {
			result1 *model.VetOrg
			result2 error
		})
	}
	fake.updateVetOrgReturnsOnCall[i] = struct {
		result1 *model.VetOrg
		result2 error
	}{result1, result2}
}

func (fake *FakeVetOrgService) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.addUserToVetOrgMutex.RLock()
	defer fake.addUserToVetOrgMutex.RUnlock()
	fake.createVetOrgMutex.RLock()
	defer fake.createVetOrgMutex.RUnlock()
	fake.deleteVetOrgMutex.RLock()
	defer fake.deleteVetOrgMutex.RUnlock()
	fake.findVetOrgByIDMutex.RLock()
	defer fake.findVetOrgByIDMutex.RUnlock()
	fake.findVetOrgByNameMutex.RLock()
	defer fake.findVetOrgByNameMutex.RUnlock()
	fake.updateVetOrgMutex.RLock()
	defer fake.updateVetOrgMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeVetOrgService) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ api.VetOrgService = new(FakeVetOrgService)
