// Code generated by counterfeiter. DO NOT EDIT.
package apifakes

import (
	"context"
	"sync"

	"github.com/jmelchio/vetlab/api"
	"github.com/jmelchio/vetlab/model"
)

type FakeVetOrgService struct {
	CreateVetOrgStub        func(ctx context.Context, vetOrg model.VetOrg) (*model.VetOrg, error)
	createVetOrgMutex       sync.RWMutex
	createVetOrgArgsForCall []struct {
		ctx    context.Context
		vetOrg model.VetOrg
	}
	createVetOrgReturns struct {
		result1 *model.VetOrg
		result2 error
	}
	createVetOrgReturnsOnCall map[int]struct {
		result1 *model.VetOrg
		result2 error
	}
	UpdateVetOrgStub        func(ctx context.Context, vetOrg model.VetOrg) (*model.VetOrg, error)
	updateVetOrgMutex       sync.RWMutex
	updateVetOrgArgsForCall []struct {
		ctx    context.Context
		vetOrg model.VetOrg
	}
	updateVetOrgReturns struct {
		result1 *model.VetOrg
		result2 error
	}
	updateVetOrgReturnsOnCall map[int]struct {
		result1 *model.VetOrg
		result2 error
	}
	DeteleVetOrgStub        func(ctx context.Context, vetOrg model.VetOrg) error
	deteleVetOrgMutex       sync.RWMutex
	deteleVetOrgArgsForCall []struct {
		ctx    context.Context
		vetOrg model.VetOrg
	}
	deteleVetOrgReturns struct {
		result1 error
	}
	deteleVetOrgReturnsOnCall map[int]struct {
		result1 error
	}
	AddUserToVetOrgStub        func(ctx context.Context, user model.User, vetOrg model.VetOrg) (*model.User, error)
	addUserToVetOrgMutex       sync.RWMutex
	addUserToVetOrgArgsForCall []struct {
		ctx    context.Context
		user   model.User
		vetOrg model.VetOrg
	}
	addUserToVetOrgReturns struct {
		result1 *model.User
		result2 error
	}
	addUserToVetOrgReturnsOnCall map[int]struct {
		result1 *model.User
		result2 error
	}
	FindVetOrgByNameStub        func(ctx context.Context, orgName string) (*model.VetOrg, error)
	findVetOrgByNameMutex       sync.RWMutex
	findVetOrgByNameArgsForCall []struct {
		ctx     context.Context
		orgName string
	}
	findVetOrgByNameReturns struct {
		result1 *model.VetOrg
		result2 error
	}
	findVetOrgByNameReturnsOnCall map[int]struct {
		result1 *model.VetOrg
		result2 error
	}
	FindVetOrgByIDStub        func(ctx context.Context, orgID string) (*model.VetOrg, error)
	findVetOrgByIDMutex       sync.RWMutex
	findVetOrgByIDArgsForCall []struct {
		ctx   context.Context
		orgID string
	}
	findVetOrgByIDReturns struct {
		result1 *model.VetOrg
		result2 error
	}
	findVetOrgByIDReturnsOnCall map[int]struct {
		result1 *model.VetOrg
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeVetOrgService) CreateVetOrg(ctx context.Context, vetOrg model.VetOrg) (*model.VetOrg, error) {
	fake.createVetOrgMutex.Lock()
	ret, specificReturn := fake.createVetOrgReturnsOnCall[len(fake.createVetOrgArgsForCall)]
	fake.createVetOrgArgsForCall = append(fake.createVetOrgArgsForCall, struct {
		ctx    context.Context
		vetOrg model.VetOrg
	}{ctx, vetOrg})
	fake.recordInvocation("CreateVetOrg", []interface{}{ctx, vetOrg})
	fake.createVetOrgMutex.Unlock()
	if fake.CreateVetOrgStub != nil {
		return fake.CreateVetOrgStub(ctx, vetOrg)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.createVetOrgReturns.result1, fake.createVetOrgReturns.result2
}

func (fake *FakeVetOrgService) CreateVetOrgCallCount() int {
	fake.createVetOrgMutex.RLock()
	defer fake.createVetOrgMutex.RUnlock()
	return len(fake.createVetOrgArgsForCall)
}

func (fake *FakeVetOrgService) CreateVetOrgArgsForCall(i int) (context.Context, model.VetOrg) {
	fake.createVetOrgMutex.RLock()
	defer fake.createVetOrgMutex.RUnlock()
	return fake.createVetOrgArgsForCall[i].ctx, fake.createVetOrgArgsForCall[i].vetOrg
}

func (fake *FakeVetOrgService) CreateVetOrgReturns(result1 *model.VetOrg, result2 error) {
	fake.CreateVetOrgStub = nil
	fake.createVetOrgReturns = struct {
		result1 *model.VetOrg
		result2 error
	}{result1, result2}
}

func (fake *FakeVetOrgService) CreateVetOrgReturnsOnCall(i int, result1 *model.VetOrg, result2 error) {
	fake.CreateVetOrgStub = nil
	if fake.createVetOrgReturnsOnCall == nil {
		fake.createVetOrgReturnsOnCall = make(map[int]struct {
			result1 *model.VetOrg
			result2 error
		})
	}
	fake.createVetOrgReturnsOnCall[i] = struct {
		result1 *model.VetOrg
		result2 error
	}{result1, result2}
}

func (fake *FakeVetOrgService) UpdateVetOrg(ctx context.Context, vetOrg model.VetOrg) (*model.VetOrg, error) {
	fake.updateVetOrgMutex.Lock()
	ret, specificReturn := fake.updateVetOrgReturnsOnCall[len(fake.updateVetOrgArgsForCall)]
	fake.updateVetOrgArgsForCall = append(fake.updateVetOrgArgsForCall, struct {
		ctx    context.Context
		vetOrg model.VetOrg
	}{ctx, vetOrg})
	fake.recordInvocation("UpdateVetOrg", []interface{}{ctx, vetOrg})
	fake.updateVetOrgMutex.Unlock()
	if fake.UpdateVetOrgStub != nil {
		return fake.UpdateVetOrgStub(ctx, vetOrg)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.updateVetOrgReturns.result1, fake.updateVetOrgReturns.result2
}

func (fake *FakeVetOrgService) UpdateVetOrgCallCount() int {
	fake.updateVetOrgMutex.RLock()
	defer fake.updateVetOrgMutex.RUnlock()
	return len(fake.updateVetOrgArgsForCall)
}

func (fake *FakeVetOrgService) UpdateVetOrgArgsForCall(i int) (context.Context, model.VetOrg) {
	fake.updateVetOrgMutex.RLock()
	defer fake.updateVetOrgMutex.RUnlock()
	return fake.updateVetOrgArgsForCall[i].ctx, fake.updateVetOrgArgsForCall[i].vetOrg
}

func (fake *FakeVetOrgService) UpdateVetOrgReturns(result1 *model.VetOrg, result2 error) {
	fake.UpdateVetOrgStub = nil
	fake.updateVetOrgReturns = struct {
		result1 *model.VetOrg
		result2 error
	}{result1, result2}
}

func (fake *FakeVetOrgService) UpdateVetOrgReturnsOnCall(i int, result1 *model.VetOrg, result2 error) {
	fake.UpdateVetOrgStub = nil
	if fake.updateVetOrgReturnsOnCall == nil {
		fake.updateVetOrgReturnsOnCall = make(map[int]struct {
			result1 *model.VetOrg
			result2 error
		})
	}
	fake.updateVetOrgReturnsOnCall[i] = struct {
		result1 *model.VetOrg
		result2 error
	}{result1, result2}
}

func (fake *FakeVetOrgService) DeteleVetOrg(ctx context.Context, vetOrg model.VetOrg) error {
	fake.deteleVetOrgMutex.Lock()
	ret, specificReturn := fake.deteleVetOrgReturnsOnCall[len(fake.deteleVetOrgArgsForCall)]
	fake.deteleVetOrgArgsForCall = append(fake.deteleVetOrgArgsForCall, struct {
		ctx    context.Context
		vetOrg model.VetOrg
	}{ctx, vetOrg})
	fake.recordInvocation("DeteleVetOrg", []interface{}{ctx, vetOrg})
	fake.deteleVetOrgMutex.Unlock()
	if fake.DeteleVetOrgStub != nil {
		return fake.DeteleVetOrgStub(ctx, vetOrg)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.deteleVetOrgReturns.result1
}

func (fake *FakeVetOrgService) DeteleVetOrgCallCount() int {
	fake.deteleVetOrgMutex.RLock()
	defer fake.deteleVetOrgMutex.RUnlock()
	return len(fake.deteleVetOrgArgsForCall)
}

func (fake *FakeVetOrgService) DeteleVetOrgArgsForCall(i int) (context.Context, model.VetOrg) {
	fake.deteleVetOrgMutex.RLock()
	defer fake.deteleVetOrgMutex.RUnlock()
	return fake.deteleVetOrgArgsForCall[i].ctx, fake.deteleVetOrgArgsForCall[i].vetOrg
}

func (fake *FakeVetOrgService) DeteleVetOrgReturns(result1 error) {
	fake.DeteleVetOrgStub = nil
	fake.deteleVetOrgReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeVetOrgService) DeteleVetOrgReturnsOnCall(i int, result1 error) {
	fake.DeteleVetOrgStub = nil
	if fake.deteleVetOrgReturnsOnCall == nil {
		fake.deteleVetOrgReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deteleVetOrgReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeVetOrgService) AddUserToVetOrg(ctx context.Context, user model.User, vetOrg model.VetOrg) (*model.User, error) {
	fake.addUserToVetOrgMutex.Lock()
	ret, specificReturn := fake.addUserToVetOrgReturnsOnCall[len(fake.addUserToVetOrgArgsForCall)]
	fake.addUserToVetOrgArgsForCall = append(fake.addUserToVetOrgArgsForCall, struct {
		ctx    context.Context
		user   model.User
		vetOrg model.VetOrg
	}{ctx, user, vetOrg})
	fake.recordInvocation("AddUserToVetOrg", []interface{}{ctx, user, vetOrg})
	fake.addUserToVetOrgMutex.Unlock()
	if fake.AddUserToVetOrgStub != nil {
		return fake.AddUserToVetOrgStub(ctx, user, vetOrg)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.addUserToVetOrgReturns.result1, fake.addUserToVetOrgReturns.result2
}

func (fake *FakeVetOrgService) AddUserToVetOrgCallCount() int {
	fake.addUserToVetOrgMutex.RLock()
	defer fake.addUserToVetOrgMutex.RUnlock()
	return len(fake.addUserToVetOrgArgsForCall)
}

func (fake *FakeVetOrgService) AddUserToVetOrgArgsForCall(i int) (context.Context, model.User, model.VetOrg) {
	fake.addUserToVetOrgMutex.RLock()
	defer fake.addUserToVetOrgMutex.RUnlock()
	return fake.addUserToVetOrgArgsForCall[i].ctx, fake.addUserToVetOrgArgsForCall[i].user, fake.addUserToVetOrgArgsForCall[i].vetOrg
}

func (fake *FakeVetOrgService) AddUserToVetOrgReturns(result1 *model.User, result2 error) {
	fake.AddUserToVetOrgStub = nil
	fake.addUserToVetOrgReturns = struct {
		result1 *model.User
		result2 error
	}{result1, result2}
}

func (fake *FakeVetOrgService) AddUserToVetOrgReturnsOnCall(i int, result1 *model.User, result2 error) {
	fake.AddUserToVetOrgStub = nil
	if fake.addUserToVetOrgReturnsOnCall == nil {
		fake.addUserToVetOrgReturnsOnCall = make(map[int]struct {
			result1 *model.User
			result2 error
		})
	}
	fake.addUserToVetOrgReturnsOnCall[i] = struct {
		result1 *model.User
		result2 error
	}{result1, result2}
}

func (fake *FakeVetOrgService) FindVetOrgByName(ctx context.Context, orgName string) (*model.VetOrg, error) {
	fake.findVetOrgByNameMutex.Lock()
	ret, specificReturn := fake.findVetOrgByNameReturnsOnCall[len(fake.findVetOrgByNameArgsForCall)]
	fake.findVetOrgByNameArgsForCall = append(fake.findVetOrgByNameArgsForCall, struct {
		ctx     context.Context
		orgName string
	}{ctx, orgName})
	fake.recordInvocation("FindVetOrgByName", []interface{}{ctx, orgName})
	fake.findVetOrgByNameMutex.Unlock()
	if fake.FindVetOrgByNameStub != nil {
		return fake.FindVetOrgByNameStub(ctx, orgName)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.findVetOrgByNameReturns.result1, fake.findVetOrgByNameReturns.result2
}

func (fake *FakeVetOrgService) FindVetOrgByNameCallCount() int {
	fake.findVetOrgByNameMutex.RLock()
	defer fake.findVetOrgByNameMutex.RUnlock()
	return len(fake.findVetOrgByNameArgsForCall)
}

func (fake *FakeVetOrgService) FindVetOrgByNameArgsForCall(i int) (context.Context, string) {
	fake.findVetOrgByNameMutex.RLock()
	defer fake.findVetOrgByNameMutex.RUnlock()
	return fake.findVetOrgByNameArgsForCall[i].ctx, fake.findVetOrgByNameArgsForCall[i].orgName
}

func (fake *FakeVetOrgService) FindVetOrgByNameReturns(result1 *model.VetOrg, result2 error) {
	fake.FindVetOrgByNameStub = nil
	fake.findVetOrgByNameReturns = struct {
		result1 *model.VetOrg
		result2 error
	}{result1, result2}
}

func (fake *FakeVetOrgService) FindVetOrgByNameReturnsOnCall(i int, result1 *model.VetOrg, result2 error) {
	fake.FindVetOrgByNameStub = nil
	if fake.findVetOrgByNameReturnsOnCall == nil {
		fake.findVetOrgByNameReturnsOnCall = make(map[int]struct {
			result1 *model.VetOrg
			result2 error
		})
	}
	fake.findVetOrgByNameReturnsOnCall[i] = struct {
		result1 *model.VetOrg
		result2 error
	}{result1, result2}
}

func (fake *FakeVetOrgService) FindVetOrgByID(ctx context.Context, orgID string) (*model.VetOrg, error) {
	fake.findVetOrgByIDMutex.Lock()
	ret, specificReturn := fake.findVetOrgByIDReturnsOnCall[len(fake.findVetOrgByIDArgsForCall)]
	fake.findVetOrgByIDArgsForCall = append(fake.findVetOrgByIDArgsForCall, struct {
		ctx   context.Context
		orgID string
	}{ctx, orgID})
	fake.recordInvocation("FindVetOrgByID", []interface{}{ctx, orgID})
	fake.findVetOrgByIDMutex.Unlock()
	if fake.FindVetOrgByIDStub != nil {
		return fake.FindVetOrgByIDStub(ctx, orgID)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.findVetOrgByIDReturns.result1, fake.findVetOrgByIDReturns.result2
}

func (fake *FakeVetOrgService) FindVetOrgByIDCallCount() int {
	fake.findVetOrgByIDMutex.RLock()
	defer fake.findVetOrgByIDMutex.RUnlock()
	return len(fake.findVetOrgByIDArgsForCall)
}

func (fake *FakeVetOrgService) FindVetOrgByIDArgsForCall(i int) (context.Context, string) {
	fake.findVetOrgByIDMutex.RLock()
	defer fake.findVetOrgByIDMutex.RUnlock()
	return fake.findVetOrgByIDArgsForCall[i].ctx, fake.findVetOrgByIDArgsForCall[i].orgID
}

func (fake *FakeVetOrgService) FindVetOrgByIDReturns(result1 *model.VetOrg, result2 error) {
	fake.FindVetOrgByIDStub = nil
	fake.findVetOrgByIDReturns = struct {
		result1 *model.VetOrg
		result2 error
	}{result1, result2}
}

func (fake *FakeVetOrgService) FindVetOrgByIDReturnsOnCall(i int, result1 *model.VetOrg, result2 error) {
	fake.FindVetOrgByIDStub = nil
	if fake.findVetOrgByIDReturnsOnCall == nil {
		fake.findVetOrgByIDReturnsOnCall = make(map[int]struct {
			result1 *model.VetOrg
			result2 error
		})
	}
	fake.findVetOrgByIDReturnsOnCall[i] = struct {
		result1 *model.VetOrg
		result2 error
	}{result1, result2}
}

func (fake *FakeVetOrgService) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.createVetOrgMutex.RLock()
	defer fake.createVetOrgMutex.RUnlock()
	fake.updateVetOrgMutex.RLock()
	defer fake.updateVetOrgMutex.RUnlock()
	fake.deteleVetOrgMutex.RLock()
	defer fake.deteleVetOrgMutex.RUnlock()
	fake.addUserToVetOrgMutex.RLock()
	defer fake.addUserToVetOrgMutex.RUnlock()
	fake.findVetOrgByNameMutex.RLock()
	defer fake.findVetOrgByNameMutex.RUnlock()
	fake.findVetOrgByIDMutex.RLock()
	defer fake.findVetOrgByIDMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeVetOrgService) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ api.VetOrgService = new(FakeVetOrgService)
